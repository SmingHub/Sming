Unit testing
============
From Wikipedia, the free encyclopedia Jump to navigation Jump to
search Software testing method by which individual units of source
code are validated


`Software development`_ Core activities

+ `Processes`_
+ `Requirements`_
+ `Design`_
+ `Engineering`_
+ `Construction`_
+ `Testing`_
+ `Debugging`_
+ `Deployment`_
+ `Maintenance`_

Paradigms and models

+ `Agile`_
+ `Cleanroom`_
+ `Incremental`_
+ `Prototyping`_
+ `Spiral`_
+ `V model`_
+ `Waterfall`_

`Methodologies`_ and frameworks

+ `ASD`_
+ `DevOps`_
+ `DAD`_
+ `DSDM`_
+ `FDD`_
+ `IID`_
+ `Kanban`_
+ `Lean SD`_
+ `LeSS`_
+ `MDD`_
+ `MSF`_
+ `PSP`_
+ `RAD`_
+ `RUP`_
+ `SAFe`_
+ `Scrum`_
+ `SEMAT`_
+ `TSP`_
+ `OpenUP`_
+ `UP`_
+ `XP`_

Supporting disciplines

+ `Configuration management`_
+ `Documentation`_
+ `Software quality assurance (SQA)`_
+ `Project management`_
+ `User experience`_

Practices

+ `ATDD`_
+ `BDD`_
+ `CCO`_
+ `CI`_
+ `CD`_
+ `DDD`_
+ `PP`_
+ `SBE`_
+ `Stand-up`_
+ `TDD`_

`Tools`_

+ `Compiler`_
+ `Debugger`_
+ `Profiler`_
+ `GUI designer`_
+ `Modeling`_
+ `IDE`_
+ `Build automation`_
+ `Release automation`_
+ `Infrastructure as code`_
+ `Testing`_

Standards and Bodies of Knowledge

+ `BABOK`_
+ `CMMI`_
+ `IEEE standards`_
+ `ISO 9001`_
+ `ISO/IEC standards`_
+ `PMBOK`_
+ `SWEBOK`_
+ `ITIL`_
+ `IREB`_

Glossaries

+ `Artificial intelligence`_
+ `Computer science`_
+ `Electrical and electronics engineering`_

Outlines

+ `Outline of software development`_



+ ` v `_
+ ` t `_
+ ` e `_



In `computer programming`_, **unit testing** is a `software testing`_
method by which individual units of `source code`_sets of one or more
computer program modules together with associated control data, usage
procedures, and operating proceduresare tested to determine whether
they are fit for use. [1]



Contents
--------


+ 1 Description
+ 2 Advantages
+ 3 Limitations and disadvantages
+ 4 Example
+ 5 As executable specifications
+ 6 Applications

    + 6.1 Extreme programming
    + 6.2 Unit testing frameworks
    + 6.3 Language-level unit testing support

+ 7 See also
+ 8 References
+ 9 External links




Description[`edit`_]
--------------------
` `_ This section **needs additional citations for `verification`_**.
Please help `improve this article`_ by `adding citations to reliable
sources`_. Unsourced material may be challenged and removed.
(September 2019) (`Learn how and when to remove this template
message`_)
Unit tests are typically `automated`_ tests written and run by
`software developers`_ to ensure that a section of an application
(known as the "unit") meets its design and behaves as intended. [2] In
`procedural programming`_, a unit could be an entire module, but it is
more commonly an individual function or procedure. In `object-oriented
programming`_, a unit is often an entire interface, such as a class,
but could be an individual method. [3] By writing tests first for the
smallest testable units, then the compound behaviors between those,
one can build up comprehensive tests for complex applications. [2]

To isolate issues that may arise, each `test case`_ should be tested
independently. Substitutes such as `method stubs`_, `mock objects`_,
[4] `fakes`_, and `test harnesses`_ can be used to assist testing a
module in isolation.

During development, a software developer may code criteria, or results
that are known to be good, into the test to verify the unit's
correctness. During test case execution, frameworks `log`_ tests that
fail any criterion and report them in a summary.

Writing and maintaining unit tests can be made faster by using
`parameterized tests`_. These allow the execution of one test multiple
times with different input sets, thus reducing test code duplication.
Unlike traditional unit tests, which are usually closed methods and
test invariant conditions, parameterized tests take any set of
parameters. Parameterized tests are supported by `TestNG`_, `JUnit`_
and its .Net counterpart, `XUnit`_. Suitable parameters for the unit
tests may be supplied manually or in some cases are automatically
generated by the test framework. In recent years support was added for
writing more powerful (unit) tests, leveraging the concept of
theories, test cases that execute the same steps, but using test data
generated at runtime, unlike regular parameterized tests that use the
same execution steps with input sets that are pre-defined. [5] [6] [7]


Advantages[`edit`_]
-------------------

The goal of unit testing is to isolate each part of the program and
show that the individual parts are correct. [1] A unit test provides a
strict, written `contract`_ that the piece of code must satisfy. As a
result, it affords several benefits.

Unit testing finds problems early in the `development cycle`_. This
includes both bugs in the programmer's implementation and flaws or
missing parts of the specification for the unit. The process of
writing a thorough set of tests forces the author to think through
inputs, outputs, and error conditions, and thus more crisply define
the unit's desired behavior. The cost of finding a bug before coding
begins or when the code is first written is considerably lower than
the cost of detecting, identifying, and correcting the bug later. Bugs
in released code may also cause costly problems for the end-users of
the software. [8] [9] [10] Code can be impossible or difficult to unit
test if poorly written, thus unit testing can force developers to
structure functions and objects in better ways.

In `test-driven development`_ (TDD), which is frequently used in both
`extreme programming`_ and `scrum`_, unit tests are created before the
code itself is written. When the tests pass, that code is considered
complete. The same unit tests are run against that function frequently
as the larger code base is developed either as the code is changed or
via an automated process with the build. If the unit tests fail, it is
considered to be a bug either in the changed code or the tests
themselves. The unit tests then allow the location of the fault or
failure to be easily traced. Since the unit tests alert the
development team of the problem before handing the code off to testers
or clients, potential problems are caught early in the development
process.

Unit testing allows the programmer to `refactor`_ code or upgrade
system libraries at a later date, and make sure the module still works
correctly (e.g., in `regression testing`_). The procedure is to write
test cases for all `functions`_ and `methods`_ so that whenever a
change causes a fault, it can be quickly identified. Unit tests detect
changes which may break a `design contract`_.

Unit testing may reduce uncertainty in the units themselves and can be
used in a `bottom-up`_ testing style approach. By testing the parts of
a program first and then testing the sum of its parts, `integration
testing`_ becomes much easier. [ `citation needed`_ ]

Unit testing provides a sort of living documentation of the system.
Developers looking to learn what functionality is provided by a unit,
and how to use it, can look at the unit tests to gain a basic
understanding of the unit's interface (`API`_). [ `citation needed`_ ]

Unit `test cases`_ embody characteristics that are critical to the
success of the unit. These characteristics can indicate
appropriate/inappropriate use of a unit as well as negative behaviors
that are to be trapped by the unit. A unit test case, in and of
itself, documents these critical characteristics, although many
software development environments do not rely solely upon code to
document the product in development. [ `citation needed`_ ]

When software is developed using a test-driven approach, the
combination of writing the unit test to specify the interface plus the
refactoring activities performed after the test has passed, may take
the place of formal design. Each unit test can be seen as a design
element specifying classes, methods, and observable behavior. [
`citation needed`_ ]


Limitations and disadvantages[`edit`_]
--------------------------------------

Testing will not catch every error in the program, because it cannot
evaluate every execution path in any but the most trivial programs.
This `problem`_ is a superset of the `halting problem`_, which is
`undecidable`_. The same is true for unit testing. Additionally, unit
testing by definition only tests the functionality of the units
themselves. Therefore, it will not catch integration errors or broader
system-level errors (such as functions performed across multiple
units, or non-functional test areas such as `performance`_). Unit
testing should be done in conjunction with other `software testing`_
activities, as they can only show the presence or absence of
particular errors; they cannot prove a complete absence of errors. To
guarantee correct behavior for every execution path and every possible
input, and ensure the absence of errors, other techniques are
required, namely the application of `formal methods`_ to proving that
a software component has no unexpected behavior. [ `citation needed`_
]

An elaborate hierarchy of unit tests does not equal integration
testing. Integration with peripheral units should be included in
integration tests, but not in unit tests. [ `citation needed`_ ]
Integration testing typically still relies heavily on humans `testing
manually`_; high-level or global-scope testing can be difficult to
automate, such that manual testing often appears faster and cheaper. [
`citation needed`_ ]

Software testing is a combinatorial problem. For example, every
Boolean decision statement requires at least two tests: one with an
outcome of "true" and one with an outcome of "false". As a result, for
every line of code written, programmers often need 3 to 5 lines of
test code. [11] This obviously takes time and its investment may not
be worth the effort. There are problems that cannot easily be tested
at all for example those that are `nondeterministic`_ or involve
multiple `threads`_. In addition, code for a unit test is likely to be
at least as buggy as the code it is testing. `Fred Brooks`_ in `The
Mythical Man-Month`_ quotes: "Never go to sea with two chronometers;
take one or three." [12] Meaning, if two `chronometers`_ contradict,
how do you know which one is correct?

Another challenge related to writing the unit tests is the difficulty
of setting up realistic and useful tests. It is necessary to create
relevant initial conditions so the part of the application being
tested behaves like part of the complete system. If these initial
conditions are not set correctly, the test will not be exercising the
code in a realistic context, which diminishes the value and accuracy
of unit test results. [13]

To obtain the intended benefits from unit testing, rigorous discipline
is needed throughout the software development process. It is essential
to keep careful records not only of the tests that have been
performed, but also of all changes that have been made to the source
code of this or any other unit in the software. Use of a `version
control`_ system is essential. If a later version of the unit fails a
particular test that it had previously passed, the version-control
software can provide a list of the source code changes (if any) that
have been applied to the unit since that time. [ `citation needed`_ ]

It is also essential to implement a sustainable process for ensuring
that test case failures are reviewed regularly and addressed
immediately. [14] If such a process is not implemented and ingrained
into the team's workflow, the application will evolve out of sync with
the unit test suite, increasing false positives and reducing the
effectiveness of the test suite.

Unit testing embedded system software presents a unique challenge:
Because the software is being developed on a different platform than
the one it will eventually run on, you cannot readily run a test
program in the actual deployment environment, as is possible with
desktop programs. [15]

Unit tests tend to be easiest when a method has input parameters and
some output. It is not as easy to create unit tests when a major
function of the method is to interact with something external to the
application. For example, a method that will work with a database
might require a mock up of database interactions to be created, which
probably won't be as comprehensive as the real database interactions.
[16] [ `bettersourceneeded`_ ]


Example[`edit`_]
----------------

Here is a set of test cases in `Java`_ that specify a number of
elements of the implementation. First, that there must be an interface
called Adder, and an implementing class with a zero-argument
constructor called AdderImpl. It goes on to `assert`_ that the Adder
interface should have a method called add, with two integer
parameters, which returns another integer. It also specifies the
behaviour of this method for a small range of values over a number of
test methods.


::

    import static org.junit.Assert.*;

    import org.junit.Test;

    public class TestAdder {

        @Test
        public void testSumPositiveNumbersOneAndOne() {
            Adder adder = new AdderImpl();
            assert(adder.add(1, 1) == 2);
        }

        // can it add the positive numbers 1 and 2?
        @Test
        public void testSumPositiveNumbersOneAndTwo() {
            Adder adder = new AdderImpl();
            assert(adder.add(1, 2) == 3);
        }

        // can it add the positive numbers 2 and 2?
        @Test
        public void testSumPositiveNumbersTwoAndTwo() {
            Adder adder = new AdderImpl();
            assert(adder.add(2, 2) == 4);
        }

        // is zero neutral?
        @Test
        public void testSumZeroNeutral() {
            Adder adder = new AdderImpl();
            assert(adder.add(0, 0) == 0);
        }

        // can it add the negative numbers -1 and -2?
        @Test
        public void testSumNegativeNumbers() {
            Adder adder = new AdderImpl();
            assert(adder.add(-1, -2) == -3);
        }

        // can it add a positive and a negative?
        @Test
        public void testSumPositiveAndNegative() {
            Adder adder = new AdderImpl();
            assert(adder.add(-1, 1) == 0);
        }

        // how about larger numbers?
        @Test
        public void testSumLargeNumbers() {
            Adder adder = new AdderImpl();
            assert(adder.add(1234, 988) == 2222);
        }

    }


In this case the unit tests, having been written first, act as a
design document specifying the form and behaviour of a desired
solution, but not the implementation details, which are left for the
programmer. Following the "do the simplest thing that could possibly
work" practice, the easiest solution that will make the test pass is
shown below.


::

    interface Adder {
        int add(int a, int b);
    }
    class AdderImpl implements Adder {
        public int add(int a, int b) {
            return a + b;
        }
    }




As executable specifications[`edit`_]
-------------------------------------
` `_ This section **does not `cite`_ any `sources`_**. Please help
`improve this section`_ by `adding citations to reliable sources`_.
Unsourced material may be challenged and `removed`_. (September 2019)
(`Learn how and when to remove this template message`_)
Using unit-tests as a design specification has one significant
advantage over other design methods: The design document (the unit-
tests themselves) can itself be used to verify the implementation. The
tests will never pass unless the developer implements a solution
according to the design.

Unit testing lacks some of the accessibility of a diagrammatic
specification such as a `UML`_ diagram, but they may be generated from
the unit test using automated tools. Most modern languages have free
tools (usually available as extensions to `IDEs`_). Free tools, like
those based on the `xUnit`_ framework, outsource to another system the
graphical rendering of a view for human consumption.


Applications[`edit`_]
---------------------


Extreme programming[`edit`_]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Unit testing is the cornerstone of `extreme programming`_, which
relies on an automated `unit testing framework`_. This automated unit
testing framework can be either third party, e.g., `xUnit`_, or
created within the development group.

Extreme programming uses the creation of unit tests for `test-driven
development`_. The developer writes a unit test that exposes either a
software requirement or a defect. This test will fail because either
the requirement isn't implemented yet, or because it intentionally
exposes a defect in the existing code. Then, the developer writes the
simplest code to make the test, along with other tests, pass.

Most code in a system is unit tested, but not necessarily all paths
through the code. Extreme programming mandates a "test everything that
can possibly break" strategy, over the traditional "test every
execution path" method. This leads developers to develop fewer tests
than classical methods, but this isn't really a problem, more a
restatement of fact, as classical methods have rarely ever been
followed methodically enough for all execution paths to have been
thoroughly tested. [ `citation needed`_ ] Extreme programming simply
recognizes that testing is rarely exhaustive (because it is often too
expensive and time-consuming to be economically viable) and provides
guidance on how to effectively focus limited resources.

Crucially, the test code is considered a first class project artifact
in that it is maintained at the same quality as the implementation
code, with all duplication removed. Developers release unit testing
code to the code repository in conjunction with the code it tests.
Extreme programming's thorough unit testing allows the benefits
mentioned above, such as simpler and more confident code development
and `refactoring`_, simplified code integration, accurate
documentation, and more modular designs. These unit tests are also
constantly run as a form of `regression test`_.

Unit testing is also critical to the concept of `Emergent Design`_. As
emergent design is heavily dependent upon refactoring, unit tests are
an integral component. [17]


Unit testing frameworks[`edit`_]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
See also: `List of unit testing frameworks`_
Unit testing frameworks are most often third-party products that are
not distributed as part of the compiler suite. They help simplify the
process of unit testing, having been developed for `a wide variety of
languages`_.

It is generally possible to perform unit testing without the support
of a specific framework by writing client code that exercises the
units under test and uses `assertions`_, `exception handling`_, or
other `control flow`_ mechanisms to signal failure. Unit testing
without a framework is valuable in that there is a `barrier to entry`_
for the adoption of unit testing; having scant unit tests is hardly
better than having none at all, whereas once a framework is in place,
adding unit tests becomes relatively easy. [18] In some frameworks
many advanced unit test features are missing or must be hand-coded.


Language-level unit testing support[`edit`_]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Some programming languages directly support unit testing. Their
grammar allows the direct declaration of unit tests without importing
a library (whether third party or standard). Additionally, the boolean
conditions of the unit tests can be expressed in the same syntax as
boolean expressions used in non-unit test code, such as what is used
for `if` and `while` statements.

Languages with built-in unit testing support include:


+ `Apex`_
+ `Cobra`_
+ `Crystal`_ [19]
+ `D`_ [20]
+ `Go`_ [21]
+ `LabVIEW`_
+ `MATLAB`_
+ `Python`_ [22]
+ `Racket`_ [23] [24]
+ `Ruby`_ [25]
+ `Rust`_ [26]


Some languages without built-in unit-testing support have very good
unit testing libraries/frameworks. Those languages include:


+ `ABAP`_
+ `C++`_
+ `C#`_
+ `Clojure`_ [27]
+ `Elixir`_
+ `Java`_
+ `JavaScript`_
+ `Objective-C`_
+ `Perl`_
+ `PHP`_
+ `PowerShell`_ [28]
+ `R`_ with testthat
+ `Scala`_
+ `tcl`_
+ `Visual Basic .NET`_
+ `Xojo`_ with XojoUnit




See also[`edit`_]
-----------------


+ `Acceptance testing`_
+ `Characterization test`_
+ `Component-based usability testing`_
+ `Design predicates`_
+ `Design by contract`_
+ `Extreme programming`_
+ `Functional testing`_
+ `Integration testing`_
+ `List of unit testing frameworks`_
+ `Regression testing`_
+ `Software archaeology`_
+ `Software testing`_
+ `Test case`_
+ `Test-driven development`_
+ `xUnit`_ a family of unit testing frameworks.





External links[`edit`_]
-----------------------


+ `Test Driven Development (Ward Cunningham's Wiki)`_

Retrieved from "`https://en.wikipedia.org/w/index.php?title=Unit_testi
ng&oldid=968650276`_" `Categories`_:

+ `Unit testing`_
+ `Extreme programming`_
+ `Software testing`_
+ `Types of tools used in software development`_

Hidden categories:

+ `Articles with short description`_
+ `Short description matches Wikidata`_
+ `Use dmy dates from April 2020`_
+ `Articles needing additional references from September 2019`_
+ `All articles needing additional references`_
+ `All articles with unsourced statements`_
+ `Articles with unsourced statements from January 2013`_
+ `Articles with unsourced statements from September 2019`_
+ `Articles with unsourced statements from October 2010`_
+ `Articles with unsourced statements from January 2010`_
+ `All articles lacking reliable references`_
+ `Articles lacking reliable references from February 2019`_
+ `Articles with unsourced statements from November 2008`_
+ `Articles with example Java code`_




Navigation menu
---------------



Personal tools
~~~~~~~~~~~~~~


+ Not logged in
+ `Talk`_
+ `Contributions`_
+ `Create account`_
+ `Log in`_




Namespaces
~~~~~~~~~~


+ `Article`_
+ `Talk`_




Variants
~~~~~~~~






Views
~~~~~


+ `Read`_
+ `Edit`_
+ `View history`_




More
~~~~






Search
~~~~~~
``_


Navigation
~~~~~~~~~~


+ `Main page`_
+ `Contents`_
+ `Current events`_
+ `Random article`_
+ `About Wikipedia`_
+ `Contact us`_
+ `Donate`_




Contribute
~~~~~~~~~~


+ `Help`_
+ `Learn to edit`_
+ `Community portal`_
+ `Recent changes`_
+ `Upload file`_




Tools
~~~~~


+ `What links here`_
+ `Related changes`_
+ `Upload file`_
+ `Special pages`_
+ `Permanent link`_
+ `Page information`_
+ `Cite this page`_
+ `Wikidata item`_




Print/export
~~~~~~~~~~~~


+ `Download as PDF`_
+ `Printable version`_




In other projects
~~~~~~~~~~~~~~~~~


+ `Wikibooks`_




Languages
~~~~~~~~~





