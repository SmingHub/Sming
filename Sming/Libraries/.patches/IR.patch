diff --git a/Sming/Libraries/.patches/IR.patch b/Sming/Libraries/.patches/IR.patch
index 138ddf6..e69de29 100644
--- a/Sming/Libraries/.patches/IR.patch
+++ b/Sming/Libraries/.patches/IR.patch
@@ -1,1124 +0,0 @@
-diff --git a/src/IRrecv.cpp b/src/IRrecv.cpp
-index 38e2c77..a70ba41 100644
---- a/src/IRrecv.cpp
-+++ b/src/IRrecv.cpp
-@@ -5,80 +5,53 @@
- 
- #include "IRrecv.h"
- #include <stddef.h>
--#ifndef UNIT_TEST
- extern "C" {
--  #include <gpio.h>
--  #include <user_interface.h>
-+#include <gpio.h>
-+#include <user_interface.h>
- }
- #include <Arduino.h>
--#endif
-+
- #include <algorithm>
- #include "IRremoteESP8266.h"
-+#include "Print.h"
- 
--#ifdef UNIT_TEST
--#undef ICACHE_RAM_ATTR
--#define ICACHE_RAM_ATTR
--#endif
- // Updated by Sebastien Warin (http://sebastien.warin.fr) for receiving IR code
- // on ESP8266
- // Updated by markszabo (https://github.com/markszabo/IRremoteESP8266) for
- // sending IR code on ESP8266
-+// Updated by Volker Vogelhuber to handle multiple IR commands while decoding not finished
- 
--// Globals
--#ifndef UNIT_TEST
--static ETSTimer timer;
--#endif
--volatile irparams_t irparams;
--irparams_t *irparams_save;  // A copy of the interrupt state while decoding.
--
--#ifndef UNIT_TEST
--static void ICACHE_RAM_ATTR read_timeout(void *arg __attribute__((unused))) {
--  os_intr_lock();
--  if (irparams.rawlen)
--    irparams.rcvstate = STATE_STOP;
--  os_intr_unlock();
--}
- 
--static void ICACHE_RAM_ATTR gpio_intr() {
--  uint32_t now = system_get_time();
--  uint32_t gpio_status = GPIO_REG_READ(GPIO_STATUS_ADDRESS);
--  static uint32_t start = 0;
--
--  os_timer_disarm(&timer);
--  GPIO_REG_WRITE(GPIO_STATUS_W1TC_ADDRESS, gpio_status);
--
--  // Grab a local copy of rawlen to reduce instructions used in IRAM.
--  // This is an ugly premature optimisation code-wise, but we do everything we
--  // can to save IRAM.
--  // It seems referencing the value via the structure uses more instructions.
--  // Less instructions means faster and less IRAM used.
--  // N.B. It saves about 13 bytes of IRAM.
--  uint16_t rawlen = irparams.rawlen;
--
--  if (rawlen >= irparams.bufsize) {
--    irparams.overflow = true;
--    irparams.rcvstate = STATE_STOP;
--  }
--
--  if (irparams.rcvstate == STATE_STOP)
--    return;
--
--  if (irparams.rcvstate == STATE_IDLE) {
--    irparams.rcvstate = STATE_MARK;
--    irparams.rawbuf[rawlen] = 1;
--  } else {
--    if (now < start)
--      irparams.rawbuf[rawlen] = (UINT32_MAX - start + now) / RAWTICK;
--    else
--      irparams.rawbuf[rawlen] = (now - start) / RAWTICK;
--  }
--  irparams.rawlen++;
-+static uint32_t   lastInterrupt;
-+volatile irparams_t irparams;
- 
--  start = now;
--  #define ONCE 0
--  os_timer_arm(&timer, irparams.timeout, ONCE);
-+static void IRAM_ATTR handleInterrupt()
-+{
-+    uint32_t now = system_get_time();
-+    uint32_t gpio_status = GPIO_REG_READ(GPIO_STATUS_ADDRESS);
-+    GPIO_REG_WRITE(GPIO_STATUS_W1TC_ADDRESS, gpio_status);
-+
-+    uint16_t index = irparams.writeIndex;
-+    int diff = now < lastInterrupt ? (UINT32_MAX - lastInterrupt + now) / RAWTICK : (now - lastInterrupt) / RAWTICK;
-+    lastInterrupt = now;
-+    if( diff > irparams.timeout )
-+        // new sequence:
-+        diff = 0;
-+
-+    irparams.rawbuf[index] = diff;
-+    Serial.printf("[%d] = %d\n", index, diff);
-+    index = (irparams.writeIndex + 1) % irparams.bufsize;
-+    Serial.printf("[%d] = %d\n", index, irparams.rawbuf[index]);
-+    // if following buffer is still start marker, we have a ring buffer overflow
-+    if( irparams.rawbuf[index] == 1 )
-+        // overflow
-+        return;
-+
-+    // Mark current (maybe not final) end of sequence
-+    irparams.rawbuf[index] = 0;
-+    irparams.writeIndex = index;
- }
--#endif  // UNIT_TEST
-+
- 
- // Start of IRrecv class -------------------
- 
-@@ -88,123 +61,64 @@ static void ICACHE_RAM_ATTR gpio_intr() {
- //   bufsize: Nr. of entries to have in the capture buffer. (Default: RAWBUF)
- //   timeout: Nr. of milli-Seconds of no signal before we stop capturing data.
- //            (Default: TIMEOUT_MS)
--//   save_buffer:  Use a second (save) buffer to decode from. (Def: false)
- // Returns:
- //   An IRrecv class object.
--IRrecv::IRrecv(uint16_t recvpin, uint16_t bufsize, uint8_t timeout,
--               bool save_buffer) {
--  irparams.recvpin = recvpin;
--  irparams.bufsize = bufsize;
--  // Ensure we are going to be able to store all possible values in the
--  // capture buffer.
--  irparams.timeout = std::min(timeout, (uint8_t) MAX_TIMEOUT_MS);
--  irparams.rawbuf = new uint16_t[bufsize];
--  if (irparams.rawbuf == NULL) {
--    DPRINTLN("Could not allocate memory for the primary IR buffer.\n"
--             "Try a smaller size for CAPTURE_BUFFER_SIZE.\nRebooting!");
--#ifndef UNIT_TEST
--    ESP.restart();  // Mem alloc failure. Reboot.
--#endif
--  }
--  // If we have been asked to use a save buffer (for decoding), then create one.
--  if (save_buffer) {
--    irparams_save = new irparams_t;
--    irparams_save->rawbuf = new uint16_t[bufsize];
--    // Check we allocated the memory successfully.
--    if (irparams_save->rawbuf == NULL) {
--      DPRINTLN("Could not allocate memory for the second IR buffer.\n"
--               "Try a smaller size for CAPTURE_BUFFER_SIZE.\nRebooting!");
--#ifndef UNIT_TEST
--      ESP.restart();  // Mem alloc failure. Reboot.
--#endif
-+IRrecv::IRrecv(uint16_t recvpin, uint16_t bufsize, uint8_t timeout ) {
-+    lastInterrupt = 0;
-+    irparams.writeIndex = 0;
-+    irparams.readIndex = 0;
-+    irparams.recvpin = recvpin;
-+    irparams.bufsize = bufsize;
-+    // Ensure we are going to be able to store all possible values in the
-+    // capture buffer.
-+    // convert to measure time (us)
-+    irparams.timeout = std::min(timeout, (uint8_t) MAX_TIMEOUT_MS) * 1000;
-+    irparams.rawbuf = new uint16_t[bufsize];
-+    if (irparams.rawbuf == NULL) {
-+        DPRINTLN("Could not allocate memory for the primary IR buffer.\n"
-+                 "Try a smaller size for CAPTURE_BUFFER_SIZE.\nRebooting!");
-+
-+        System.restart();  // Mem alloc failure. Reboot.
-     }
--  } else {
--    irparams_save = NULL;
--  }
-+    memset( irparams.rawbuf, 0, sizeof(irparams.rawbuf));
-+    irparams.rawbuf[0] = 1;
- #if DECODE_HASH
--  unknown_threshold = UNKNOWN_THRESHOLD;
-+    unknown_threshold = UNKNOWN_THRESHOLD;
- #endif  // DECODE_HASH
- }
- 
- // Class destructor
- IRrecv::~IRrecv(void) {
--  delete [] irparams.rawbuf;
--  if (irparams_save != NULL) {
--    delete [] irparams_save->rawbuf;
--    delete irparams_save;
--  }
-+    delete [] irparams.rawbuf;
- }
- 
-+typedef Delegate<void()> IRDelegate;
-+
- // initialization
- void IRrecv::enableIRIn() {
--  // initialize state machine variables
--  resume();
--
--#ifndef UNIT_TEST
--  // Initialize timer
--  os_timer_disarm(&timer);
--  os_timer_setfn(&timer, reinterpret_cast<os_timer_func_t *>(read_timeout),
--                 NULL);
--
--  // Attach Interrupt
--  attachInterrupt(irparams.recvpin, gpio_intr, CHANGE);
--#endif
-+    // Attach Interrupt
-+//    attachInterrupt(irparams.recvpin, IRDelegate(&IRrecv::handleInterrupt, this), CHANGE);
-+    attachInterrupt(irparams.recvpin, handleInterrupt, CHANGE );
- }
- 
- void IRrecv::disableIRIn() {
--#ifndef UNIT_TEST
--  os_timer_disarm(&timer);
--  detachInterrupt(irparams.recvpin);
--#endif
-+    detachInterrupt(irparams.recvpin);
- }
- 
- void IRrecv::resume() {
--  irparams.rcvstate = STATE_IDLE;
--  irparams.rawlen = 0;
--  irparams.overflow = false;
--}
- 
--// Make a copy of the interrupt state & buffer data.
--// Needed because irparams is marked as volatile, thus memcpy() isn't allowed.
--// Only call this when you know the interrupt handlers won't modify anything.
--// i.e. In STATE_STOP.
--//
--// Args:
--//   src: Pointer to an irparams_t structure to copy from.
--//   dst: Pointer to an irparams_t structure to copy to.
--void IRrecv::copyIrParams(volatile irparams_t *src, irparams_t *dst) {
--  // Typecast src and dst addresses to (char *)
--  char *csrc = (char *) src;  // NOLINT(readability/casting)
--  char *cdst = (char *) dst;  // NOLINT(readability/casting)
--
--  // Save the pointer to the destination's rawbuf so we don't lose it as
--  // the for-loop/copy after this will overwrite it with src's rawbuf pointer.
--  // This isn't immediately obvious due to typecasting/different variable names.
--  uint16_t *dst_rawbuf_ptr;
--  dst_rawbuf_ptr = dst->rawbuf;
--
--  // Copy contents of src[] to dst[]
--  for (uint16_t i = 0; i < sizeof(irparams_t); i++)
--    cdst[i] = csrc[i];
--
--  // Restore the buffer pointer
--  dst->rawbuf = dst_rawbuf_ptr;
--
--  // Copy the rawbuf
--  for (uint16_t i = 0; i < dst->bufsize; i++)
--    dst->rawbuf[i] = src->rawbuf[i];
- }
- 
- // Obtain the maximum number of entries possible in the capture buffer.
- // i.e. It's size.
- uint16_t IRrecv::getBufSize() {
--  return irparams.bufsize;
-+    return irparams.bufsize;
- }
- 
- #if DECODE_HASH
- // Set the minimum length we will consider for reporting UNKNOWN message types.
- void IRrecv::setUnknownThreshold(uint16_t length) {
--  unknown_threshold = length;
-+    unknown_threshold = length;
- }
- #endif  // DECODE_HASH
- 
-@@ -220,200 +134,200 @@ void IRrecv::setUnknownThreshold(uint16_t length) {
- //          the interrupt's memory/state. NULL means don't save it.
- // Returns:
- //   A boolean indicating if an IR message is ready or not.
--bool IRrecv::decode(decode_results *results, irparams_t *save) {
--  // Proceed only if an IR message been received.
--#ifndef UNIT_TEST
--  if (irparams.rcvstate != STATE_STOP)
--    return false;
--#endif
--
--  // Clear the entry we are currently pointing to when we got the timeout.
--  // i.e. Stopped collecting IR data.
--  // It's junk as we never wrote an entry to it and can only confuse decoding.
--  // This is done here rather than logically the best place in read_timeout()
--  // as it saves a few bytes of ICACHE_RAM as that routine is bound to an
--  // interrupt. decode() is not stored in ICACHE_RAM.
--  // Another better option would be to zero the entire irparams.rawbuf[] on
--  // resume() but that is a much more expensive operation compare to this.
--  irparams.rawbuf[irparams.rawlen] = 0;
--
--  bool resumed = false;  // Flag indicating if we have resumed.
--
--  // If we were requested to use a save buffer previously, do so.
--  if (save == NULL)
--    save = irparams_save;
--
--  if (save == NULL) {
--    // We haven't been asked to copy it so use the existing memory.
--#ifndef UNIT_TEST
--    results->rawbuf = irparams.rawbuf;
--    results->rawlen = irparams.rawlen;
--    results->overflow = irparams.overflow;
--#endif
--  } else {
--    copyIrParams(&irparams, save);  // Duplicate the interrupt's memory.
--    resume();  // It's now safe to rearm. The IR message won't be overridden.
--    resumed = true;
--    // Point the results at the saved copy.
--    results->rawbuf = save->rawbuf;
--    results->rawlen = save->rawlen;
--    results->overflow = save->overflow;
--  }
--
--  // Reset any previously partially processed results.
--  results->decode_type = UNKNOWN;
--  results->bits = 0;
--  results->value = 0;
--  results->address = 0;
--  results->command = 0;
--  results->repeat = false;
-+bool IRrecv::decode(decode_results *results) {
-+    //noInterrupts();
-+    uint32_t now = system_get_time();
-+    int diff = now < lastInterrupt ? (UINT32_MAX - lastInterrupt + now) / RAWTICK : (now - lastInterrupt) / RAWTICK;
-+    if( diff > irparams.timeout )
-+        irparams.rawbuf[irparams.writeIndex] = 1;
-+
-+//    while( irparams.rawbuf[irparams.readIndex] == 1 )
-+//        irparams.readIndex = (irparams.readIndex + 1) % irparams.bufsize;
-+    //interrupts();
-+    // Check if there is already valid data
-+    int decodeIndex = irparams.readIndex;
-+    results->rawbuf = decodeBuf;
-+    decodeBuf[0] = 1;
-+    results->rawlen = 0;
-+    uint16_t value;
-+    do
-+    {
-+        value = irparams.rawbuf[decodeIndex];
-+        switch (value) {
-+        case 0: // no data available yet
-+            return false;
-+        case 1: // new marker found, decode current decodeBuffer
-+            if( results->rawlen == 0 )
-+                return false;
-+            decodeBuf[results->rawlen] = 0;
-+            // Let writer write into buffer again, as we've copied it already
-+            irparams.rawbuf[irparams.readIndex] = 0;
-+            irparams.readIndex = decodeIndex;
-+            break;
-+        default:
-+            Serial.printf("WI: %d RI: %d\n", (int)irparams.writeIndex, (int)irparams.readIndex, irparams.bufsize );
-+            Serial.printf("%d ", value);
-+            decodeBuf[++results->rawlen] = value;
-+            break;
-+        }
-+        decodeIndex = (decodeIndex + 1) % irparams.bufsize;
-+    } while( value != 1 && results->rawlen < MAX_CODE_LEN);
-+    Serial.printf("\nRawlen: %d ", results->rawlen);
-+
-+    // Reset any previously partially processed results.
-+    results->decode_type = UNKNOWN;
-+    results->bits = 0;
-+    results->value = 0;
-+    results->address = 0;
-+    results->command = 0;
-+    results->repeat = false;
- 
- #if DECODE_AIWA_RC_T501
--  DPRINTLN("Attempting Aiwa RC T501 decode");
--  // Try decodeAiwaRCT501() before decodeSanyoLC7461() & decodeNEC()
--  // because the protocols are similar. This protocol is more specific than
--  // those ones, so should got before them.
--  if (decodeAiwaRCT501(results))
--    return true;
-+    DPRINTLN("Attempting Aiwa RC T501 decode");
-+    // Try decodeAiwaRCT501() before decodeSanyoLC7461() & decodeNEC()
-+    // because the protocols are similar. This protocol is more specific than
-+    // those ones, so should got before them.
-+    if (decodeAiwaRCT501(results))
-+        return true;
- #endif
- #if DECODE_SANYO
--  DPRINTLN("Attempting Sanyo LC7461 decode");
--  // Try decodeSanyoLC7461() before decodeNEC() because the protocols are
--  // similar in timings & structure, but the Sanyo one is much longer than the
--  // NEC protocol (42 vs 32 bits) so this one should be tried first to try to
--  // reduce false detection as a NEC packet.
--  if (decodeSanyoLC7461(results))
--    return true;
-+    DPRINTLN("Attempting Sanyo LC7461 decode");
-+    // Try decodeSanyoLC7461() before decodeNEC() because the protocols are
-+    // similar in timings & structure, but the Sanyo one is much longer than the
-+    // NEC protocol (42 vs 32 bits) so this one should be tried first to try to
-+    // reduce false detection as a NEC packet.
-+    if (decodeSanyoLC7461(results))
-+        return true;
- #endif
- #if DECODE_CARRIER_AC
--  DPRINTLN("Attempting Carrier AC decode");
--  // Try decodeCarrierAC() before decodeNEC() because the protocols are
--  // similar in timings & structure, but the Carrier one is much longer than the
--  // NEC protocol (3x32 bits vs 1x32 bits) so this one should be tried first to
--  // try to reduce false detection as a NEC packet.
--  if (decodeCarrierAC(results))
--    return true;
-+    DPRINTLN("Attempting Carrier AC decode");
-+    // Try decodeCarrierAC() before decodeNEC() because the protocols are
-+    // similar in timings & structure, but the Carrier one is much longer than the
-+    // NEC protocol (3x32 bits vs 1x32 bits) so this one should be tried first to
-+    // try to reduce false detection as a NEC packet.
-+    if (decodeCarrierAC(results))
-+        return true;
- #endif
- #if DECODE_NEC
--  DPRINTLN("Attempting NEC decode");
--  if (decodeNEC(results))
--    return true;
-+    DPRINTLN("Attempting NEC decode");
-+    if (decodeNEC(results))
-+        return true;
- #endif
- #if DECODE_SONY
--  DPRINTLN("Attempting Sony decode");
--  if (decodeSony(results))
--    return true;
-+    DPRINTLN("Attempting Sony decode");
-+    if (decodeSony(results))
-+        return true;
- #endif
- #if DECODE_MITSUBISHI
--  DPRINTLN("Attempting Mitsubishi decode");
--  if (decodeMitsubishi(results))
--    return true;
-+    DPRINTLN("Attempting Mitsubishi decode");
-+    if (decodeMitsubishi(results))
-+        return true;
- #endif
- #if DECODE_RC5
--  DPRINTLN("Attempting RC5 decode");
--  if (decodeRC5(results))
--    return true;
-+    DPRINTLN("Attempting RC5 decode");
-+    if (decodeRC5(results))
-+        return true;
- #endif
- #if DECODE_RC6
--  DPRINTLN("Attempting RC6 decode");
--  if (decodeRC6(results))
--    return true;
-+    DPRINTLN("Attempting RC6 decode");
-+    if (decodeRC6(results))
-+        return true;
- #endif
- #if DECODE_RCMM
--  DPRINTLN("Attempting RC-MM decode");
--  if (decodeRCMM(results))
--    return true;
-+    DPRINTLN("Attempting RC-MM decode");
-+    if (decodeRCMM(results))
-+        return true;
- #endif
- #if DECODE_FUJITSU_AC
--  // Fujitsu A/C needs to precede Panasonic and Denon as it has a short
--  // message which looks exactly the same as a Panasonic/Denon message.
--  DPRINTLN("Attempting Fujitsu A/C decode");
--  if (decodeFujitsuAC(results))
--    return true;
-+    // Fujitsu A/C needs to precede Panasonic and Denon as it has a short
-+    // message which looks exactly the same as a Panasonic/Denon message.
-+    DPRINTLN("Attempting Fujitsu A/C decode");
-+    if (decodeFujitsuAC(results))
-+        return true;
- #endif
- #if DECODE_DENON
--  // Denon needs to precede Panasonic as it is a special case of Panasonic.
--  DPRINTLN("Attempting Denon decode");
--  if (decodeDenon(results, DENON_48_BITS) ||
--      decodeDenon(results, DENON_BITS) ||
--      decodeDenon(results, DENON_LEGACY_BITS))
--    return true;
-+    // Denon needs to precede Panasonic as it is a special case of Panasonic.
-+    DPRINTLN("Attempting Denon decode");
-+    if (decodeDenon(results, DENON_48_BITS) ||
-+            decodeDenon(results, DENON_BITS) ||
-+            decodeDenon(results, DENON_LEGACY_BITS))
-+        return true;
- #endif
- #if DECODE_PANASONIC
--  DPRINTLN("Attempting Panasonic decode");
--  if (decodePanasonic(results))
--    return true;
-+    DPRINTLN("Attempting Panasonic decode");
-+    if (decodePanasonic(results))
-+        return true;
- #endif
- #if DECODE_LG
--  DPRINTLN("Attempting LG (28-bit) decode");
--  if (decodeLG(results, LG_BITS, true))
--    return true;
--  DPRINTLN("Attempting LG (32-bit) decode");
--  // LG32 should be tried before Samsung
--  if (decodeLG(results, LG32_BITS, true))
--    return true;
-+    DPRINTLN("Attempting LG (28-bit) decode");
-+    if (decodeLG(results, LG_BITS, true))
-+        return true;
-+    DPRINTLN("Attempting LG (32-bit) decode");
-+    // LG32 should be tried before Samsung
-+    if (decodeLG(results, LG32_BITS, true))
-+        return true;
- #endif
- #if DECODE_JVC
--  DPRINTLN("Attempting JVC decode");
--  if (decodeJVC(results))
--    return true;
-+    DPRINTLN("Attempting JVC decode");
-+    if (decodeJVC(results))
-+        return true;
- #endif
- #if DECODE_SAMSUNG
--  DPRINTLN("Attempting SAMSUNG decode");
--  if (decodeSAMSUNG(results))
--    return true;
-+    DPRINTLN("Attempting SAMSUNG decode");
-+    if (decodeSAMSUNG(results))
-+        return true;
- #endif
- #if DECODE_WHYNTER
--  DPRINTLN("Attempting Whynter decode");
--  if (decodeWhynter(results))
--    return true;
-+    DPRINTLN("Attempting Whynter decode");
-+    if (decodeWhynter(results))
-+        return true;
- #endif
- #if DECODE_DISH
--  DPRINTLN("Attempting DISH decode");
--  if (decodeDISH(results))
--    return true;
-+    DPRINTLN("Attempting DISH decode");
-+    if (decodeDISH(results))
-+        return true;
- #endif
- #if DECODE_SHARP
--  DPRINTLN("Attempting Sharp decode");
--  if (decodeSharp(results))
--    return true;
-+    DPRINTLN("Attempting Sharp decode");
-+    if (decodeSharp(results))
-+        return true;
- #endif
- #if DECODE_COOLIX
--  DPRINTLN("Attempting Coolix decode");
--  if (decodeCOOLIX(results))
--    return true;
-+    DPRINTLN("Attempting Coolix decode");
-+    if (decodeCOOLIX(results))
-+        return true;
- #endif
- #if DECODE_NIKAI
--  DPRINTLN("Attempting Nikai decode");
--  if (decodeNikai(results))
--    return true;
-+    DPRINTLN("Attempting Nikai decode");
-+    if (decodeNikai(results))
-+        return true;
- #endif
- #if DECODE_KELVINATOR
--  DPRINTLN("Attempting Kelvinator decode");
--  if (decodeKelvinator(results))
--    return true;
-+    DPRINTLN("Attempting Kelvinator decode");
-+    if (decodeKelvinator(results))
-+        return true;
- #endif
- #if DECODE_DAIKIN
--  DPRINTLN("Attempting Daikin decode");
--  if (decodeDaikin(results))
--    return true;
-+    DPRINTLN("Attempting Daikin decode");
-+    if (decodeDaikin(results))
-+        return true;
- #endif
- #if DECODE_TOSHIBA_AC
--  DPRINTLN("Attempting Toshiba AC decode");
--  if (decodeToshibaAC(results))
--    return true;
-+    DPRINTLN("Attempting Toshiba AC decode");
-+    if (decodeToshibaAC(results))
-+        return true;
- #endif
- #if DECODE_MIDEA
--  DPRINTLN("Attempting Midea decode");
--  if (decodeMidea(results))
--    return true;
-+    DPRINTLN("Attempting Midea decode");
-+    if (decodeMidea(results))
-+        return true;
- #endif
- #if DECODE_MAGIQUEST
--  DPRINTLN("Attempting Magiquest decode");
--  if (decodeMagiQuest(results))
--    return true;
-+    DPRINTLN("Attempting Magiquest decode");
-+    if (decodeMagiQuest(results))
-+        return true;
- #endif
--/* NOTE: Disabled due to poor quality.
-+    /* NOTE: Disabled due to poor quality.
- #if DECODE_SANYO
-   // The Sanyo S866500B decoder is very poor quality & depricated.
-   // *IF* you are going to enable it, do it near last to avoid false positive
-@@ -424,34 +338,32 @@ bool IRrecv::decode(decode_results *results, irparams_t *save) {
- #endif
- */
- #if DECODE_NEC
--  // Some devices send NEC-like codes that don't follow the true NEC spec.
--  // This should detect those. e.g. Apple TV remote etc.
--  // This needs to be done after all other codes that use strict and some
--  // other protocols that are NEC-like as well, as turning off strict may
--  // cause this to match other valid protocols.
--  DPRINTLN("Attempting NEC (non-strict) decode");
--  if (decodeNEC(results, NEC_BITS, false)) {
--    results->decode_type = NEC_LIKE;
--    return true;
--  }
-+    // Some devices send NEC-like codes that don't follow the true NEC spec.
-+    // This should detect those. e.g. Apple TV remote etc.
-+    // This needs to be done after all other codes that use strict and some
-+    // other protocols that are NEC-like as well, as turning off strict may
-+    // cause this to match other valid protocols.
-+    DPRINTLN("Attempting NEC (non-strict) decode");
-+    if (decodeNEC(results, NEC_BITS, false)) {
-+        results->decode_type = NEC_LIKE;
-+        return true;
-+    }
- #endif
- #if DECODE_LASERTAG
--  DPRINTLN("Attempting Lasertag decode");
--  if (decodeLasertag(results))
--    return true;
-+    DPRINTLN("Attempting Lasertag decode");
-+    if (decodeLasertag(results))
-+        return true;
- #endif
- #if DECODE_HASH
--  // decodeHash returns a hash on any input.
--  // Thus, it needs to be last in the list.
--  // If you add any decodes, add them before this.
--  if (decodeHash(results)) {
--    return true;
--  }
-+    // decodeHash returns a hash on any input.
-+    // Thus, it needs to be last in the list.
-+    // If you add any decodes, add them before this.
-+    if (decodeHash(results)) {
-+        return true;
-+    }
- #endif  // DECODE_HASH
--  // Throw away and start over
--  if (!resumed)  // Check if we have already resumed.
--    resume();
--  return false;
-+    // Throw away and start over
-+    return false;
- }
- 
- // Calculate the lower bound of the nr. of ticks.
-@@ -463,9 +375,9 @@ bool IRrecv::decode(decode_results *results, irparams_t *save) {
- // Returns:
- //   Nr. of ticks.
- uint32_t IRrecv::ticksLow(uint32_t usecs, uint8_t tolerance, uint16_t delta) {
--  // max() used to ensure the result can't drop below 0 before the cast.
--  return((uint32_t) std::max(
--      (int32_t) (usecs * (1.0 - tolerance / 100.0) - delta), 0));
-+    // max() used to ensure the result can't drop below 0 before the cast.
-+    return((uint32_t) std::max(
-+               (int32_t) (usecs * (1.0 - tolerance / 100.0) - delta), 0));
- }
- 
- // Calculate the upper bound of the nr. of ticks.
-@@ -477,7 +389,7 @@ uint32_t IRrecv::ticksLow(uint32_t usecs, uint8_t tolerance, uint16_t delta) {
- // Returns:
- //   Nr. of ticks.
- uint32_t IRrecv::ticksHigh(uint32_t usecs, uint8_t tolerance, uint16_t delta) {
--  return((uint32_t) (usecs * (1.0 + tolerance / 100.0)) + 1 + delta);
-+    return((uint32_t) (usecs * (1.0 + tolerance / 100.0)) + 1 + delta);
- }
- 
- // Check if we match a pulse(measured) with the desired within
-@@ -493,15 +405,15 @@ uint32_t IRrecv::ticksHigh(uint32_t usecs, uint8_t tolerance, uint16_t delta) {
- //   Boolean: true if it matches, false if it doesn't.
- bool IRrecv::match(uint32_t measured, uint32_t desired,
-                    uint8_t tolerance, uint16_t delta) {
--  measured *= RAWTICK;  // Convert to uSecs.
--  DPRINT("Matching: ");
--  DPRINT(ticksLow(desired, tolerance, delta));
--  DPRINT(" <= ");
--  DPRINT(measured);
--  DPRINT(" <= ");
--  DPRINTLN(ticksHigh(desired, tolerance, delta));
--  return (measured >= ticksLow(desired, tolerance, delta) &&
--          measured <= ticksHigh(desired, tolerance, delta));
-+    measured *= RAWTICK;  // Convert to uSecs.
-+    DPRINT("Matching: ");
-+    DPRINT(ticksLow(desired, tolerance, delta));
-+    DPRINT(" <= ");
-+    DPRINT(measured);
-+    DPRINT(" <= ");
-+    DPRINTLN(ticksHigh(desired, tolerance, delta));
-+    return (measured >= ticksLow(desired, tolerance, delta) &&
-+            measured <= ticksHigh(desired, tolerance, delta));
- }
- 
- 
-@@ -519,26 +431,26 @@ bool IRrecv::match(uint32_t measured, uint32_t desired,
- //   Boolean: true if it matches, false if it doesn't.
- bool IRrecv::matchAtLeast(uint32_t measured, uint32_t desired,
-                           uint8_t tolerance, uint16_t delta) {
--  measured *= RAWTICK;  // Convert to uSecs.
--  DPRINT("Matching ATLEAST ");
--  DPRINT(measured);
--  DPRINT(" vs ");
--  DPRINT(desired);
--  DPRINT(". Matching: ");
--  DPRINT(measured);
--  DPRINT(" >= ");
--  DPRINT(ticksLow(std::min(desired, MS_TO_USEC(irparams.timeout)), tolerance,
--                  delta));
--  DPRINT(" [min(");
--  DPRINT(ticksLow(desired, tolerance, delta));
--  DPRINT(", ");
--  DPRINT(ticksLow(MS_TO_USEC(irparams.timeout), tolerance, delta));
--  DPRINTLN(")]");
--  // We really should never get a value of 0, except as the last value
--  // in the buffer. If that is the case, then assume infinity and return true.
--  if (measured == 0) return true;
--  return measured >= ticksLow(std::min(desired, MS_TO_USEC(irparams.timeout)),
--                              tolerance, delta);
-+    measured *= RAWTICK;  // Convert to uSecs.
-+    DPRINT("Matching ATLEAST ");
-+    DPRINT(measured);
-+    DPRINT(" vs ");
-+    DPRINT(desired);
-+    DPRINT(". Matching: ");
-+    DPRINT(measured);
-+    DPRINT(" >= ");
-+    DPRINT(ticksLow(std::min(desired, MS_TO_USEC(irparams.timeout)), tolerance,
-+                    delta));
-+    DPRINT(" [min(");
-+    DPRINT(ticksLow(desired, tolerance, delta));
-+    DPRINT(", ");
-+    DPRINT(ticksLow(MS_TO_USEC(irparams.timeout), tolerance, delta));
-+    DPRINTLN(")]");
-+    // We really should never get a value of 0, except as the last value
-+    // in the buffer. If that is the case, then assume infinity and return true.
-+    if (measured == 0) return true;
-+    return measured >= ticksLow(std::min(desired, MS_TO_USEC(irparams.timeout)),
-+                                tolerance, delta);
- }
- 
- // Check if we match a mark signal(measured) with the desired within
-@@ -554,14 +466,14 @@ bool IRrecv::matchAtLeast(uint32_t measured, uint32_t desired,
- //   Boolean: true if it matches, false if it doesn't.
- bool IRrecv::matchMark(uint32_t measured, uint32_t desired,
-                        uint8_t tolerance, int16_t excess) {
--  DPRINT("Matching MARK ");
--  DPRINT(measured * RAWTICK);
--  DPRINT(" vs ");
--  DPRINT(desired);
--  DPRINT(" + ");
--  DPRINT(excess);
--  DPRINT(". ");
--  return match(measured, desired + excess, tolerance);
-+    DPRINT("Matching MARK ");
-+    DPRINT(measured * RAWTICK);
-+    DPRINT(" vs ");
-+    DPRINT(desired);
-+    DPRINT(" + ");
-+    DPRINT(excess);
-+    DPRINT(". ");
-+    return match(measured, desired + excess, tolerance);
- }
- 
- // Check if we match a space signal(measured) with the desired within
-@@ -577,16 +489,17 @@ bool IRrecv::matchMark(uint32_t measured, uint32_t desired,
- //   Boolean: true if it matches, false if it doesn't.
- bool IRrecv::matchSpace(uint32_t measured, uint32_t desired,
-                         uint8_t tolerance, int16_t excess) {
--  DPRINT("Matching SPACE ");
--  DPRINT(measured * RAWTICK);
--  DPRINT(" vs ");
--  DPRINT(desired);
--  DPRINT(" - ");
--  DPRINT(excess);
--  DPRINT(". ");
--  return match(measured, desired - excess, tolerance);
-+    DPRINT("Matching SPACE ");
-+    DPRINT(measured * RAWTICK);
-+    DPRINT(" vs ");
-+    DPRINT(desired);
-+    DPRINT(" - ");
-+    DPRINT(excess);
-+    DPRINT(". ");
-+    return match(measured, desired - excess, tolerance);
- }
- 
-+
- /* -----------------------------------------------------------------------
-  * hashdecode - decode an arbitrary IR code.
-  * Instead of decoding using a standard encoding scheme
-@@ -605,12 +518,12 @@ bool IRrecv::matchSpace(uint32_t measured, uint32_t desired,
- // 1 if newval is equal, and 2 if newval is longer
- // Use a tolerance of 20%
- int16_t IRrecv::compare(uint16_t oldval, uint16_t newval) {
--  if (newval < oldval * 0.8)
--    return 0;
--  else if (oldval < newval * 0.8)
--    return 2;
--  else
--    return 1;
-+    if (newval < oldval * 0.8)
-+        return 0;
-+    else if (oldval < newval * 0.8)
-+        return 2;
-+    else
-+        return 1;
- }
- 
- #if DECODE_HASH
-@@ -619,25 +532,25 @@ int16_t IRrecv::compare(uint16_t oldval, uint16_t newval) {
-  * This isn't a "real" decoding, just an arbitrary value.
-  */
- bool IRrecv::decodeHash(decode_results *results) {
--  // Require at least some samples to prevent triggering on noise
--  if (results->rawlen < unknown_threshold)
--    return false;
--  int32_t hash = FNV_BASIS_32;
--  // 'rawlen - 2' to avoid the look ahead from going out of bounds.
--  // Should probably be -3 to avoid comparing the trailing space entry,
--  // however it is left this way for compatibility with previously captured
--  // values.
--  for (uint16_t i = 1; i < results->rawlen - 2; i++) {
--    int16_t value = compare(results->rawbuf[i], results->rawbuf[i + 2]);
--    // Add value into the hash
--    hash = (hash * FNV_PRIME_32) ^ value;
--  }
--  results->value = hash & 0xFFFFFFFF;
--  results->bits = results->rawlen / 2;
--  results->address = 0;
--  results->command = 0;
--  results->decode_type = UNKNOWN;
--  return true;
-+    // Require at least some samples to prevent triggering on noise
-+    if (results->rawlen < unknown_threshold)
-+        return false;
-+    int32_t hash = FNV_BASIS_32;
-+    // 'rawlen - 2' to avoid the look ahead from going out of bounds.
-+    // Should probably be -3 to avoid comparing the trailing space entry,
-+    // however it is left this way for compatibility with previously captured
-+    // values.
-+    for (uint16_t i = 1; i < results->rawlen - 2; i++) {
-+        int16_t value = compare(results->rawbuf[i], results->rawbuf[i + 2]);
-+        // Add value into the hash
-+        hash = (hash * FNV_PRIME_32) ^ value;
-+    }
-+    results->value = hash & 0xFFFFFFFF;
-+    results->bits = results->rawlen / 2;
-+    results->address = 0;
-+    results->command = 0;
-+    results->decode_type = UNKNOWN;
-+    return true;
- }
- #endif  // DECODE_HASH
- 
-@@ -661,41 +574,41 @@ match_result_t IRrecv::matchData(volatile uint16_t *data_ptr,
-                                  const uint16_t zeromark,
-                                  const uint32_t zerospace,
-                                  const uint8_t tolerance) {
--  match_result_t result;
--  result.success = false;
--  result.data = 0;
--  if (onemark == zeromark) {  // Is this space encoded data format?
--    for (result.used = 0;
--         result.used < nbits * 2;
--         result.used += 2, data_ptr++) {
--      if (!matchMark(*data_ptr, onemark, tolerance))
--        return result;  // Fail
--      data_ptr++;
--      if (matchSpace(*data_ptr, onespace, tolerance))
--        result.data = (result.data << 1) | 1;
--      else if (matchSpace(*data_ptr, zerospace, tolerance))
--        result.data <<= 1;
--      else
--        return result;  // Fail
--    }
--    result.success = true;
--  } else if (onespace == zerospace) {  // Is this mark encoded data format?
--    for (result.used = 0;
--         result.used < nbits * 2;
--         result.used += 2, data_ptr++) {
--      if (matchMark(*data_ptr, onemark, tolerance))
--        result.data = (result.data << 1) | 1;
--      else if (matchMark(*data_ptr, zeromark, tolerance))
--        result.data <<= 1;
--      else
--        return result;  // Fail
--      data_ptr++;
--      if (!matchSpace(*data_ptr, onespace, tolerance))
--        return result;  // Fail
-+    match_result_t result;
-+    result.success = false;
-+    result.data = 0;
-+    if (onemark == zeromark) {  // Is this space encoded data format?
-+        for (result.used = 0;
-+             result.used < nbits * 2;
-+             result.used += 2, data_ptr++) {
-+            if (!matchMark(*data_ptr, onemark, tolerance))
-+                return result;  // Fail
-+            data_ptr++;
-+            if (matchSpace(*data_ptr, onespace, tolerance))
-+                result.data = (result.data << 1) | 1;
-+            else if (matchSpace(*data_ptr, zerospace, tolerance))
-+                result.data <<= 1;
-+            else
-+                return result;  // Fail
-+        }
-+        result.success = true;
-+    } else if (onespace == zerospace) {  // Is this mark encoded data format?
-+        for (result.used = 0;
-+             result.used < nbits * 2;
-+             result.used += 2, data_ptr++) {
-+            if (matchMark(*data_ptr, onemark, tolerance))
-+                result.data = (result.data << 1) | 1;
-+            else if (matchMark(*data_ptr, zeromark, tolerance))
-+                result.data <<= 1;
-+            else
-+                return result;  // Fail
-+            data_ptr++;
-+            if (!matchSpace(*data_ptr, onespace, tolerance))
-+                return result;  // Fail
-+        }
-+        result.success = true;
-     }
--    result.success = true;
--  }
--  return result;
-+    return result;
- }
- 
- // End of IRrecv class -------------------
-diff --git a/src/IRrecv.h b/src/IRrecv.h
-index 18bee3d..1599bf9 100644
---- a/src/IRrecv.h
-+++ b/src/IRrecv.h
-@@ -6,9 +6,7 @@
- #ifndef IRRECV_H_
- #define IRRECV_H_
- 
--#ifndef UNIT_TEST
- #include <Arduino.h>
--#endif
- #include <stddef.h>
- #define __STDC_LIMIT_MACROS
- #include <stdint.h>
-@@ -61,14 +59,14 @@
- // Types
- // information for the interrupt handler
- typedef struct {
--  uint8_t recvpin;              // pin for IR data from detector
--  uint8_t rcvstate;             // state machine
-+  uint8_t recvpin;              // pin for IR data from detector  
-   uint16_t timer;               // state timer, counts 50uS ticks.
-   uint16_t bufsize;             // max. nr. of entries in the capture buffer.
-+  uint16_t   writeIndex;
-+  uint16_t readIndex;
-   uint16_t *rawbuf;             // raw data
-   // uint16_t is used for rawlen as it saves 3 bytes of iram in the interrupt
-   // handler. Don't ask why, I don't know. It just does.
--  uint16_t rawlen;              // counter of entries in rawbuf.
-   uint8_t overflow;             // Buffer overflow indicator.
-   uint8_t timeout;              // Nr. of milliSeconds before we give up.
- } irparams_t;
-@@ -110,10 +108,9 @@ class decode_results {
- class IRrecv {
-  public:
-   explicit IRrecv(uint16_t recvpin, uint16_t bufsize = RAWBUF,
--                  uint8_t timeout = TIMEOUT_MS,
--                  bool save_buffer = false);  // Constructor
-+                  uint8_t timeout = TIMEOUT_MS);  // Constructor
-   ~IRrecv();  // Destructor
--  bool decode(decode_results *results, irparams_t *save = NULL);
-+  bool decode(decode_results *results);
-   void enableIRIn();
-   void disableIRIn();
-   void resume();
-@@ -131,12 +128,12 @@ class IRrecv {
- 
-  private:
- #endif
--  irparams_t *irparams_save;
-+  uint16_t   decodeBuf[MAX_CODE_LEN];
- #if DECODE_HASH
-   uint16_t unknown_threshold;
- #endif
-+  //void handleInterrupt();
-   // These are called by decode
--  void copyIrParams(volatile irparams_t *src, irparams_t *dst);
-   int16_t compare(uint16_t oldval, uint16_t newval);
-   static uint32_t ticksLow(uint32_t usecs, uint8_t tolerance = TOLERANCE,
-                            uint16_t delta = 0);
-diff --git a/src/IRremoteESP8266.h b/src/IRremoteESP8266.h
-index 4449ca6..eb536b0 100644
---- a/src/IRremoteESP8266.h
-+++ b/src/IRremoteESP8266.h
-@@ -283,6 +283,8 @@ enum decode_type_t {
- #define LASERTAG_BITS               13U
- #define LASERTAG_MIN_REPEAT          0U
- 
-+#define MAX_CODE_LEN    DAIKIN_RAW_BITS
-+
- // Turn on Debugging information by uncommenting the following line.
- // #define DEBUG 1
- 
-diff --git a/src/IRsend.h b/src/IRsend.h
-index ad53938..b8a9be8 100644
---- a/src/IRsend.h
-+++ b/src/IRsend.h
-@@ -12,7 +12,7 @@
- // Updated by markszabo (https://github.com/markszabo/IRremoteESP8266) for
- // sending IR code on ESP8266
- 
--#if TEST || UNIT_TEST
-+#if defined(TEST) || defined(UNIT_TEST)
- #define VIRTUAL virtual
- #else
- #define VIRTUAL
-diff --git a/src/ir_JVC.cpp b/src/ir_JVC.cpp
-index 0efc51b..5eb2bbe 100644
---- a/src/ir_JVC.cpp
-+++ b/src/ir_JVC.cpp
-@@ -69,7 +69,7 @@ void IRsend::sendJVC(uint64_t data, uint16_t nbits, uint16_t repeat) {
-                 data, nbits, 38, true, 0,  // Repeats are handles elsewhere.
-                 33);
-     // Wait till the end of the repeat time window before we send another code.
--    space(std::max(JVC_RPT_LENGTH - JVC_MIN_GAP - usecs.elapsed(), 0U));
-+    space(max(JVC_RPT_LENGTH - JVC_MIN_GAP - usecs.elapsed(), 0U));
-     usecs.reset();
-   }
- }
-diff --git a/src/ir_Mitsubishi.cpp b/src/ir_Mitsubishi.cpp
-index 363eec6..f22a7d4 100644
---- a/src/ir_Mitsubishi.cpp
-+++ b/src/ir_Mitsubishi.cpp
-@@ -263,8 +263,8 @@ bool IRMitsubishiAC::getPower() {
- 
- // Set the temp. in deg C
- void IRMitsubishiAC::setTemp(uint8_t temp) {
--  temp = std::max((uint8_t) MITSUBISHI_AC_MIN_TEMP, temp);
--  temp = std::min((uint8_t) MITSUBISHI_AC_MAX_TEMP, temp);
-+  temp = max((uint8_t) MITSUBISHI_AC_MIN_TEMP, temp);
-+  temp = min((uint8_t) MITSUBISHI_AC_MAX_TEMP, temp);
-   remote_state[7] = temp - MITSUBISHI_AC_MIN_TEMP;
- }
- 
-@@ -317,7 +317,7 @@ void IRMitsubishiAC::setMode(uint8_t mode) {
- 
- // Set the requested vane operation mode of the a/c unit.
- void IRMitsubishiAC::setVane(uint8_t mode) {
--  mode = std::min(mode, (uint8_t) 0b111);  // bounds check
-+  mode = min(mode, (uint8_t) 0b111);  // bounds check
-   mode |= 0b1000;
-   mode <<= 3;
-   remote_state[9] &= 0b11000111;  // Clear the previous setting.
-diff --git a/src/ir_RC5_RC6.cpp b/src/ir_RC5_RC6.cpp
-index 8fcd097..8f6f319 100644
---- a/src/ir_RC5_RC6.cpp
-+++ b/src/ir_RC5_RC6.cpp
-@@ -110,7 +110,7 @@ void IRsend::sendRC5(uint64_t data, uint16_t nbits, uint16_t repeat) {
-         space(RC5_T1);
-       }
-     // Footer
--    space(std::max(RC5_MIN_GAP, RC5_MIN_COMMAND_LENGTH - usecTimer.elapsed()));
-+    space(max(RC5_MIN_GAP, RC5_MIN_COMMAND_LENGTH - usecTimer.elapsed()));
-   }
- }
- 
-diff --git a/src/ir_RCMM.cpp b/src/ir_RCMM.cpp
-index 3d8d244..6462c82 100644
---- a/src/ir_RCMM.cpp
-+++ b/src/ir_RCMM.cpp
-@@ -80,7 +80,7 @@ void IRsend::sendRCMM(uint64_t data, uint16_t nbits, uint16_t repeat) {
-     mark(RCMM_BIT_MARK);
-     // Protocol requires us to wait at least RCMM_RPT_LENGTH usecs from the
-     // start or RCMM_MIN_GAP usecs.
--    space(std::max(RCMM_RPT_LENGTH - usecs.elapsed(), RCMM_MIN_GAP));
-+    space(max(RCMM_RPT_LENGTH - usecs.elapsed(), RCMM_MIN_GAP));
-   }
- }
- #endif
-@@ -107,7 +107,7 @@ bool IRrecv::decodeRCMM(decode_results *results, uint16_t nbits, bool strict) {
-     return false;  // Not enough entries to ever be RCMM.
- 
-   // Calc the maximum size in bits, the message can be, or that we can accept.
--  int16_t maxBitSize = std::min((uint16_t) results->rawlen - 5,
-+  int16_t maxBitSize = min((uint16_t) results->rawlen - 5,
-                                 (uint16_t) sizeof(data) * 8);
-   // Compliance
-   if (strict) {
-diff --git a/src/ir_Whynter.cpp b/src/ir_Whynter.cpp
-index 17489f4..b92bdd2 100644
---- a/src/ir_Whynter.cpp
-+++ b/src/ir_Whynter.cpp
-@@ -67,7 +67,7 @@ void IRsend::sendWhynter(uint64_t data, uint16_t nbits, uint16_t repeat) {
-                 WHYNTER_BIT_MARK, WHYNTER_MIN_GAP,
-                 data, nbits, 38, true, 0,  // Repeats are already handled.
-                 50);
--    space(std::max(WHYNTER_MIN_COMMAND_LENGTH - WHYNTER_MIN_GAP -
-+    space(max(WHYNTER_MIN_COMMAND_LENGTH - WHYNTER_MIN_GAP -
-                    usecTimer.elapsed(), 0U));
-   }
- }
diff --git a/Sming/Makefile b/Sming/Makefile
index f53dccf..dbb5f63 100644
--- a/Sming/Makefile
+++ b/Sming/Makefile
@@ -181,6 +181,10 @@ EXTRA_INCDIR    = include system/include Wiring Libraries SmingCore $(SDK_BASE)/
 THIRD_PARTY_DATA = third-party/rboot/Makefile
 EXTRA_INCDIR += third-party/rboot third-party/rboot/appcode 
 
+# => IRremote8266
+MODULES += Libraries/IR/src
+EXTRA_INCDIR += Libraries/IR/src
+
 # => spiffs
 THIRD_PARTY_DATA += third-party/spiffs/makefile
 MODULES		     += third-party/spiffs/src
