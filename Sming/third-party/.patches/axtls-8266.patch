diff -Nuar third-party/axtls-8266/Makefile Sming/axtls-8266/Makefile
--- third-party/axtls-8266/Makefile	2016-11-21 11:11:56.708179012 +0100
+++ Sming/axtls-8266/Makefile	2016-11-21 11:03:46.952184516 +0100
@@ -1,3 +1,5 @@
+-include Makefile.local
+
 TOOLCHAIN_PREFIX := xtensa-lx106-elf-
 CC := $(TOOLCHAIN_PREFIX)gcc
 AR := $(TOOLCHAIN_PREFIX)ar
@@ -6,7 +8,9 @@
 
 
 XTENSA_LIBS ?= $(shell $(CC) -print-sysroot)
-
+ifeq ($(XTENSA_LIBS),)
+	XTENSA_LIBS = $(ESP_HOME)/xtensa-lx106-elf/
+endif
 
 OBJ_FILES := \
 	crypto/aes.o \
diff -Nuar third-party/axtls-8266/Makefile.local.template Sming/axtls-8266/Makefile.local.template
--- third-party/axtls-8266/Makefile.local.template	1970-01-01 01:00:00.000000000 +0100
+++ Sming/axtls-8266/Makefile.local.template	2016-11-21 11:02:07.672185632 +0100
@@ -0,0 +1,3 @@
+# Set this to SDK path and save as Makefile.local
+SDK_BASE := $(HOME)/esp8266/sdk
+
diff -Nuar third-party/axtls-8266/replacements/libc.c Sming/axtls-8266/replacements/libc.c
--- third-party/axtls-8266/replacements/libc.c	1970-01-01 01:00:00.000000000 +0100
+++ Sming/axtls-8266/replacements/libc.c	2016-11-21 11:03:47.152184514 +0100
@@ -0,0 +1,29 @@
+/*
+ libc_replacements.c - replaces libc functions with functions
+ from Espressif SDK
+ Copyright (c) 2015 Ivan Grokhotkov. All rights reserved.
+ This file is part of the esp8266 core for Arduino environment.
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2.1 of the License, or (at your option) any later version.
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+ You should have received a copy of the GNU Lesser General Public
+ License along with this library; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ Modified 03 April 2015 by Markus Sattler
+ */
+
+#include <stdint.h>
+#include "espinc/c_types_compatible.h"
+#include <stdarg.h>
+
+extern int ets_putc(int);
+extern int ets_vprintf(int (*print_function)(int), const char * format, va_list arg);
+
+int vprintf(const char * format, va_list arg) {
+    return ets_vprintf(ets_putc, format, arg);
+}
diff -Nuar third-party/axtls-8266/replacements/mem.c Sming/axtls-8266/replacements/mem.c
--- third-party/axtls-8266/replacements/mem.c	1970-01-01 01:00:00.000000000 +0100
+++ Sming/axtls-8266/replacements/mem.c	2016-11-21 11:02:07.672185632 +0100
@@ -0,0 +1,84 @@
+/*
+ * Memory functions for ESP8266 taken from Arduino-Esp project
+
+  WiFiClientSecure.cpp - Variant of WiFiClient with TLS support
+  Copyright (c) 2015 Ivan Grokhotkov. All rights reserved.
+  This file is part of the esp8266 core for Arduino environment.
+
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2.1 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+*/
+
+#include <stdint.h>
+#include "espinc/c_types_compatible.h"
+
+// Those Espressif functions are needed
+extern void *pvPortMalloc(size_t xWantedSize, const char *file, uint32 line);
+extern void *pvPortRealloc(void* ptr, size_t xWantedSize, const char *file, uint32 line);
+extern void vPortFree(void *ptr, const char *file, uint32 line);
+extern void *ets_memset(void *s, int c, size_t n);
+
+#include "mem_manager.h"
+
+#define free os_free
+#define malloc os_malloc
+#define realloc os_realloc
+#define memset ets_memset
+
+#ifdef DEBUG_TLS_MEM
+extern int m_printf(const char *fmt, ...);
+#define DEBUG_TLS_MEM_PRINT(...) m_printf(__VA_ARGS__)
+#else
+#define DEBUG_TLS_MEM_PRINT(...)
+#endif
+
+void* ax_port_malloc(size_t size, const char* file, int line) {
+    void* result = (void *)malloc(size);
+
+    if (result == NULL) {
+        DEBUG_TLS_MEM_PRINT("%s:%d malloc %d failed, left %d\r\n", file, line, size, system_get_free_heap_size());
+
+        while(true){}
+    }
+    if (size >= 1024)
+        DEBUG_TLS_MEM_PRINT("%s:%d malloc %d, left %d\r\n", file, line, size, system_get_free_heap_size());
+    return result;
+}
+
+void* ax_port_calloc(size_t size, size_t count, const char* file, int line) {
+    void* result = (void* )ax_port_malloc(size * count, file, line);
+    memset(result, 0, size * count);
+    return result;
+}
+
+void* ax_port_realloc(void* ptr, size_t size, const char* file, int line) {
+    void* result = (void* )realloc(ptr, size);
+    if (result == NULL) {
+        DEBUG_TLS_MEM_PRINT("%s:%d realloc %d failed, left %d\r\n", file, line, size, system_get_free_heap_size());
+        while(true){}
+    }
+    if (size >= 1024)
+        DEBUG_TLS_MEM_PRINT("%s:%d realloc %d, left %d\r\n", file, line, size, system_get_free_heap_size());
+    return result;
+}
+
+void ax_port_free(void* ptr) {
+    free(ptr);
+    uint32_t *p = (uint32_t*) ptr;
+    size_t size = p[-3];
+    if (size >= 1024)
+        DEBUG_TLS_MEM_PRINT("free %d, left %d\r\n", p[-3], system_get_free_heap_size());
+}
diff -Nuar third-party/axtls-8266/ssl/os_port.h Sming/axtls-8266/ssl/os_port.h
--- third-party/axtls-8266/ssl/os_port.h	2016-11-21 11:11:56.712179012 +0100
+++ Sming/axtls-8266/ssl/os_port.h	2016-11-21 11:03:47.216184514 +0100
@@ -60,7 +60,14 @@
 
 #if defined(ESP8266)
 
+extern int ets_putc(int character);
+extern void ets_printf(const char*, ...);
+extern int ax_port_read(int clientfd, uint8_t *buf, int bytes_needed);
+extern int ax_port_write(int clientfd, uint8_t *buf, uint16_t bytes_needed);
+
 #include "util/time.h"
+extern void gettimeofday(struct timeval* t,void* timezone);
+
 #include <errno.h>
 #define alloca(size) __builtin_alloca(size)
 #define TTY_FLUSH()
@@ -96,7 +103,8 @@
 #define be64toh(x) __bswap_constant_64(x)
 #endif
 
-void ax_wdt_feed();
+extern void system_soft_wdt_feed(void);
+#define ax_wdt_feed system_soft_wdt_feed
 
 #elif defined(WIN32)
 
@@ -190,6 +198,18 @@
 #endif  /* Not Win32 */
 
 /* some functions to mutate the way these work */
+#define malloc(A)       ax_port_malloc(A, __FILE__, __LINE__)
+#ifndef realloc
+#define realloc(A,B)    ax_port_realloc(A,B, __FILE__, __LINE__)
+#endif
+#define calloc(A,B)     ax_port_calloc(A,B, __FILE__, __LINE__)
+#define free(x)         ax_port_free(x)
+
+EXP_FUNC void * STDCALL ax_port_malloc(size_t s, const char*, int);
+EXP_FUNC void * STDCALL ax_port_realloc(void *y, size_t s, const char*, int);
+EXP_FUNC void * STDCALL ax_port_calloc(size_t n, size_t s, const char*, int);
+EXP_FUNC void * STDCALL ax_port_free(void*);
+
 inline uint32_t htonl(uint32_t n){
   return ((n & 0xff) << 24) |
     ((n & 0xff00) << 8) |
diff -Nuar third-party/axtls-8266/ssl/tls1.c Sming/axtls-8266/ssl/tls1.c
--- third-party/axtls-8266/ssl/tls1.c	2016-11-21 11:11:56.712179012 +0100
+++ Sming/axtls-8266/ssl/tls1.c	2016-11-21 11:03:47.216184514 +0100
@@ -1306,6 +1306,9 @@
     int read_len, is_client = IS_SET_SSL_FLAG(SSL_IS_CLIENT);
     uint8_t *buf = ssl->bm_data;
 
+    if (ssl->can_free_certificates) {
+        certificate_free(ssl);
+    }
     if (IS_SET_SSL_FLAG(SSL_SENT_CLOSE_NOTIFY))
         return SSL_CLOSE_NOTIFY;
 
diff -Nuar third-party/axtls-8266/ssl/tls1.h Sming/axtls-8266/ssl/tls1.h
--- third-party/axtls-8266/ssl/tls1.h	2016-11-21 11:11:56.712179012 +0100
+++ Sming/axtls-8266/ssl/tls1.h	2016-11-21 11:03:47.216184514 +0100
@@ -43,7 +43,6 @@
 #include "version.h"
 #include "config.h"
 #include "os_int.h"
-#include "os_port.h"
 #include "crypto.h"
 #include "crypto_misc.h"
 
diff -Nuar third-party/axtls-8266/tools/make_certs.sh Sming/axtls-8266/tools/make_certs.sh
--- third-party/axtls-8266/tools/make_certs.sh	2016-11-21 11:11:56.712179012 +0100
+++ Sming/axtls-8266/tools/make_certs.sh	2016-11-21 11:02:07.676185632 +0100
@@ -1,6 +1,6 @@
 #!/bin/sh
 #
-# Copyright (c) 2007-2016, Cameron Rich
+# Copyright (c) 2007, Cameron Rich
 #
 # All rights reserved.
 #
@@ -29,7 +29,12 @@
 # THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #
 
-AXDIR=`pwd`/`dirname $0`
+OLDCWD=`pwd`
+
+if [ -z $AXDIR ]; then
+	AXDIR = $OLDCWD/`dirname $0`
+fi
+
 CWD=`mktemp -d` && cd $dir
 cd $CWD 
 
@@ -56,7 +61,7 @@
 
 [ req_distinguished_name ]
  O                      = $PROJECT_NAME
- CN                     = localhost
+ CN                     = 127.0.0.1
 EOF
 
 cat > device_cert.conf << EOF  
@@ -69,16 +74,21 @@
 EOF
 
 # private key generation
-openssl genrsa -out axTLS.ca_key.pem 2048
+openssl genrsa -out axTLS.ca_key.pem 1024
+openssl genrsa -out axTLS.key_512.pem 512
 openssl genrsa -out axTLS.key_1024.pem 1024
+openssl genrsa -out axTLS.key_1042.pem 1042
 openssl genrsa -out axTLS.key_2048.pem 2048
 openssl genrsa -out axTLS.key_4096.pem 4096
 openssl genrsa -out axTLS.device_key.pem 1024
-openssl genrsa -aes128 -passout pass:abcd -out axTLS.key_aes128.pem 1024
-openssl genrsa -aes256 -passout pass:abcd -out axTLS.key_aes256.pem 1024
+openssl genrsa -aes128 -passout pass:abcd -out axTLS.key_aes128.pem 512
+openssl genrsa -aes256 -passout pass:abcd -out axTLS.key_aes256.pem 512
+
 
 # convert private keys into DER format
+openssl rsa -in axTLS.key_512.pem -out axTLS.key_512 -outform DER
 openssl rsa -in axTLS.key_1024.pem -out axTLS.key_1024 -outform DER
+openssl rsa -in axTLS.key_1042.pem -out axTLS.key_1042 -outform DER
 openssl rsa -in axTLS.key_2048.pem -out axTLS.key_2048 -outform DER
 openssl rsa -in axTLS.key_4096.pem -out axTLS.key_4096 -outform DER
 openssl rsa -in axTLS.device_key.pem -out axTLS.device_key -outform DER
@@ -86,8 +96,12 @@
 # cert requests
 openssl req -out axTLS.ca_x509.req -key axTLS.ca_key.pem -new \
             -config ./ca_cert.conf 
+openssl req -out axTLS.x509_512.req -key axTLS.key_512.pem -new \
+            -config ./certs.conf 
 openssl req -out axTLS.x509_1024.req -key axTLS.key_1024.pem -new \
             -config ./certs.conf 
+openssl req -out axTLS.x509_1042.req -key axTLS.key_1042.pem -new \
+            -config ./certs.conf 
 openssl req -out axTLS.x509_2048.req -key axTLS.key_2048.pem -new \
             -config ./certs.conf 
 openssl req -out axTLS.x509_4096.req -key axTLS.key_4096.pem -new \
@@ -101,32 +115,25 @@
 
 # generate the actual certs.
 openssl x509 -req -in axTLS.ca_x509.req -out axTLS.ca_x509.pem \
-            -sha1 -days 5000 -signkey axTLS.ca_key.pem \
-            -CAkey axTLS.ca_key.pem
-openssl x509 -req -in axTLS.ca_x509.req -out axTLS.ca_x509_sha256.pem \
-            -sha256 -days 5000 -signkey axTLS.ca_key.pem \
-            -CAkey axTLS.ca_key.pem
+            -sha1 -days 5000 -signkey axTLS.ca_key.pem
+openssl x509 -req -in axTLS.x509_512.req -out axTLS.x509_512.pem \
+            -sha1 -CAcreateserial -days 5000 \
+            -CA axTLS.ca_x509.pem -CAkey axTLS.ca_key.pem
 openssl x509 -req -in axTLS.x509_1024.req -out axTLS.x509_1024.pem \
             -sha1 -CAcreateserial -days 5000 \
             -CA axTLS.ca_x509.pem -CAkey axTLS.ca_key.pem
-openssl x509 -req -in axTLS.x509_1024.req -out axTLS.x509_1024_sha256.pem \
-            -sha256 -CAcreateserial -days 5000 \
-            -CA axTLS.ca_x509_sha256.pem -CAkey axTLS.ca_key.pem
-openssl x509 -req -in axTLS.x509_1024.req -out axTLS.x509_1024_sha384.pem \
-            -sha384 -CAcreateserial -days 5000 \
-            -CA axTLS.ca_x509_sha256.pem -CAkey axTLS.ca_key.pem
-openssl x509 -req -in axTLS.x509_1024.req -out axTLS.x509_1024_sha512.pem \
-            -sha512 -CAcreateserial -days 5000 \
-            -CA axTLS.ca_x509_sha256.pem -CAkey axTLS.ca_key.pem
-openssl x509 -req -in axTLS.x509_2048.req -out axTLS.x509_2048.pem \
+openssl x509 -req -in axTLS.x509_1042.req -out axTLS.x509_1042.pem \
             -sha1 -CAcreateserial -days 5000 \
             -CA axTLS.ca_x509.pem -CAkey axTLS.ca_key.pem
+openssl x509 -req -in axTLS.x509_2048.req -out axTLS.x509_2048.pem \
+            -md5 -CAcreateserial -days 5000 \
+            -CA axTLS.ca_x509.pem -CAkey axTLS.ca_key.pem
 openssl x509 -req -in axTLS.x509_4096.req -out axTLS.x509_4096.pem \
-            -sha1 -CAcreateserial -days 5000 \
+            -md5 -CAcreateserial -days 5000 \
             -CA axTLS.ca_x509.pem -CAkey axTLS.ca_key.pem
 openssl x509 -req -in axTLS.x509_device.req -out axTLS.x509_device.pem \
             -sha1 -CAcreateserial -days 5000 \
-            -CA axTLS.x509_1024.pem -CAkey axTLS.key_1024.pem
+            -CA axTLS.x509_512.pem -CAkey axTLS.key_512.pem
 openssl x509 -req -in axTLS.x509_aes128.req \
             -out axTLS.x509_aes128.pem \
             -sha1 -CAcreateserial -days 5000 \
@@ -139,33 +146,35 @@
 # note: must be root to do this
 DATE_NOW=`date`
 if date -s "Jan 1 2025"; then
-openssl x509 -req -in axTLS.x509_1024.req -out axTLS.x509_bad_before.pem \
+openssl x509 -req -in axTLS.x509_512.req -out axTLS.x509_bad_before.pem \
             -sha1 -CAcreateserial -days 365 \
             -CA axTLS.ca_x509.pem -CAkey axTLS.ca_key.pem
 date -s "$DATE_NOW"
 touch axTLS.x509_bad_before.pem
 fi
-openssl x509 -req -in axTLS.x509_1024.req -out axTLS.x509_bad_after.pem \
+openssl x509 -req -in axTLS.x509_512.req -out axTLS.x509_bad_after.pem \
             -sha1 -CAcreateserial -days -365 \
             -CA axTLS.ca_x509.pem -CAkey axTLS.ca_key.pem
 
 # some cleanup
 rm axTLS*.req
-rm *.srl
+rm axTLS.srl
 rm *.conf
 
 # need this for the client tests
 openssl x509 -in axTLS.ca_x509.pem -outform DER -out axTLS.ca_x509.cer 
+openssl x509 -in axTLS.x509_512.pem -outform DER -out axTLS.x509_512.cer
 openssl x509 -in axTLS.x509_1024.pem -outform DER -out axTLS.x509_1024.cer
+openssl x509 -in axTLS.x509_1042.pem -outform DER -out axTLS.x509_1042.cer
 openssl x509 -in axTLS.x509_2048.pem -outform DER -out axTLS.x509_2048.cer
 openssl x509 -in axTLS.x509_4096.pem -outform DER -out axTLS.x509_4096.cer
 openssl x509 -in axTLS.x509_device.pem -outform DER -out axTLS.x509_device.cer
 
 # generate pkcs8 files (use RC4-128 for encryption)
-openssl pkcs8 -in axTLS.key_1024.pem -passout pass:abcd -topk8 -v1 PBE-SHA1-RC4-128 -out axTLS.encrypted_pem.p8
-openssl pkcs8 -in axTLS.key_1024.pem -passout pass:abcd -topk8 -outform DER -v1 PBE-SHA1-RC4-128 -out axTLS.encrypted.p8
-openssl pkcs8 -in axTLS.key_1024.pem -nocrypt -topk8 -out axTLS.unencrypted_pem.p8
-openssl pkcs8 -in axTLS.key_1024.pem -nocrypt -topk8 -outform DER -out axTLS.unencrypted.p8
+openssl pkcs8 -in axTLS.key_512.pem -passout pass:abcd -topk8 -v1 PBE-SHA1-RC4-128 -out axTLS.encrypted_pem.p8
+openssl pkcs8 -in axTLS.key_512.pem -passout pass:abcd -topk8 -outform DER -v1 PBE-SHA1-RC4-128 -out axTLS.encrypted.p8
+openssl pkcs8 -in axTLS.key_512.pem -nocrypt -topk8 -out axTLS.unencrypted_pem.p8
+openssl pkcs8 -in axTLS.key_512.pem -nocrypt -topk8 -outform DER -out axTLS.unencrypted.p8
 
 # generate pkcs12 files (use RC4-128 for encryption)
 openssl pkcs12 -export -in axTLS.x509_1024.pem -inkey axTLS.key_1024.pem -certfile axTLS.ca_x509.pem -keypbe PBE-SHA1-RC4-128 -certpbe PBE-SHA1-RC4-128 -name "p12_with_CA" -out axTLS.withCA.p12 -password pass:abcd
@@ -177,6 +186,6 @@
 
 # set default key/cert for use in the server
 xxd -i axTLS.x509_1024.cer | sed -e \
-        "s/axTLS_x509_1024_cer/default_certificate/" > $AXDIR/../ssl/cert.h
+        "s/axTLS_x509_1024_cer/default_certificate/" > $AXDIR/cert.h
 xxd -i axTLS.key_1024 | sed -e \
-        "s/axTLS_key_1024/default_private_key/" > $AXDIR/../ssl/private_key.h
+        "s/axTLS_key_1024/default_private_key/" > $AXDIR/private_key.h

diff --git third-party/axtls-8266/compat/README.md third-party/axtls-8266/compat/README.md
index fff3383..d3fcb4f 100644
--- third-party/axtls-8266/compat/README.md
+++ third-party/axtls-8266/compat/README.md
@@ -1,3 +1,23 @@
+Introduction
+============
+The name "Lwirax" comes from **LW**ip**R**aw and **AX**tls. 
+[LWIP raw](http://lwip.wikia.com/wiki/Raw/TCP) is the asynchronous mode in which the Light Weight IP (LWIP) stack works in popular
+microcontrollers like ESP8266. As the name states it is designed to fit in embedded devices with limited resources and provides 
+the TCP/IP functionality in your application or device. 
+
+[axTLS](http://axtls.sourceforge.net/) is a light weight TLS(aka SSL) implementation. 
+
+Using axTLS with LWIP raw mode is not straight forward. "Lwirax" tries to ease the burden and provides the "glue" between the two.
+It is tested and working with [axTLS for ESP8266](https://github.com/igrr/axtls-8266) but should be easy to use in other
+platforms. Lwirax is proven to work with axTLS version 1.4.9 till 2.0.0+. It might work also for other versions.
+
+For a fully working project and integration take a look at [Sming Tasty](https://github.com/slaff/Sming). 
+Take a look at [TcpConnection.cpp](https://github.com/slaff/Sming/blob/tasty/Sming/SmingCore/Network/TcpConnection.cpp) for a start.
+The [Basic_Ssl](https://github.com/slaff/Sming/tree/tasty/samples/Basic_Ssl) sample can be used to make a test SSL connection with google servers.
+
+Usage
+=====
+
 If you are using [LWIP raw tcp mode](http://lwip.wikia.com/wiki/Raw/TCP) and want to add SSL support below are the steps that can help you to achieve this with the help of [axTLS]( http://axtls.sourceforge.net/ ).
 		
 First you have to include the `lwipr_compat.h` header.
@@ -31,7 +51,7 @@ res = tcp_connect(tcp, &addr, port, staticOnConnected);
 
 ```
 
-Now we should add in our `staticOnConnected` funciton code to create new ssl context and ssl object. 
+Now we should add in our `staticOnConnected` function code to create new ssl context and ssl object. 
 In the example below the `sslObj` and `sslContext` are defined as global
 
 ```C
@@ -76,9 +96,9 @@ err_t staticOnConnected(void *arg, struct tcp_pcb *tcp, err_t err)
 Once we are connected we can send and receive information. For the receiving part we can do the following
 
 ```C
-err_t staticOnReceive(void *arg, struct tcp_pcb *tcp, struct pbuf *p, err_t err)
+err_t staticOnReceive(void *arg, struct tcp_pcb *tcp, struct pbuf *pin, err_t err)
 {
-	uint8_t *read_buf = NULL;
+	struct pbuf* pout;
 	int read_bytes = 0;
 
 	printf("Err: %d\n", err);
@@ -88,17 +108,26 @@ err_t staticOnReceive(void *arg, struct tcp_pcb *tcp, struct pbuf *p, err_t err)
 		return -1;
 	}
 
-	read_bytes = axl_ssl_read(sslObj, &read_buf, tcp, p);
+	read_bytes = axl_ssl_read(sslObj, tcp, p, &pout);
 	if(read_bytes > 0) {
-		printf("Got data: %s", read_buf);
-		// @TODO: Do something useful with the read_buf 
+	    // free the SSL pbuf and put the decrypted data in the brand new pout pbuf
+		if(p != NULL) {
+			pbuf_free(p);
+		}
+		
+		printf("Got decrypted data length: %d", read_bytes);
+		
+		// put the decrypted data in a brand new pbuf
+		p = pout;
+	
+		// @TODO: Continue to work with the p buf containing the decrypted data 
 	}
 
 	return ERR_OK;
 }
 ```
 
-In the receiving part you can also add debug code to display more information about the SSL handshake, once it was successul.
+In the receiving part you can also add debug code to display more information about the SSL handshake, once it was successful.
 
 
 ```C
@@ -108,10 +137,9 @@ err_t staticOnReceive(void *arg, struct tcp_pcb *tcp, struct pbuf *p, err_t err)
 	const char *common_name = NULL;
 	
 	// ..
-	read_bytes = axl_ssl_read(sslObj, &read_buf, tcp, p);
+	read_bytes = axl_ssl_read(sslObj, tcp, p, &pout);
 	if(read_bytes > 0) {
-		printf("Got data: %s", read_buf);
-		// @TODO: Do something useful with the read_buf 
+	    // ...
 	}
 	
 	if(!show_info && ssl_handshake_status(sslObj) == SSL_OK) {
@@ -120,7 +148,7 @@ err_t staticOnReceive(void *arg, struct tcp_pcb *tcp, struct pbuf *p, err_t err)
 			printf("Common Name:\t\t\t%s\n", common_name);
 		}
 
-		// These two funcitons below can be found in the axtls examples
+		// These two functions below can be found in the axtls examples
 		display_session_id(sslObj); 
 		display_cipher(sslObj);
 		show_info = 1;
@@ -146,4 +174,8 @@ void someSendingfunction() {
 
 ```
 
+Platforms
+=========
+If you want to adapt Lwirax for other platforms make sure to add your platform specific changes to the *lwip_platform.h* file.
+
 Good luck and send your success stories at slaff@attachix.com.
diff --git third-party/axtls-8266/compat/lwipr_compat.c third-party/axtls-8266/compat/lwipr_compat.c
index a334454..c6de55b 100644
--- third-party/axtls-8266/compat/lwipr_compat.c
+++ third-party/axtls-8266/compat/lwipr_compat.c
@@ -14,9 +14,17 @@ AxlTcpDataArray axlFdArray;
 
 /**
  * Function that should be called once we are ready to use the axTLS - LWIP raw compatibility
+ * @param int capacity -  the desired capacity
+ * @return int - the actual capacity
+ * 		   - 0 - not enough memory
+ * 		   > 0 && capacity != actual capacity - the axl_init was already called and this is the current capacity
  */
-void axl_init(int capacity) {
-	ax_fd_init(&axlFdArray, capacity);
+int axl_init(int capacity) {
+	if(axlFdArray.capacity > 0 && axlFdArray.data != NULL) {
+		// we are already initialized.
+		return axlFdArray.capacity;
+	}
+	return ax_fd_init(&axlFdArray, capacity);
 }
 
 /**
@@ -38,11 +46,11 @@ int axl_free(struct tcp_pcb *tcp) {
 	}
 
 	AxlTcpDataArray *vector = &axlFdArray;
-	AXL_DEBUG("AXL: Freeing %d tcp item", vector->size);
+	AXL_DEBUG_PRINT("axl_free: Freeing %d tcp item", vector->size);
 	for (i = 0; i < vector->size; i++) {
 		if (vector->data[i].tcp == tcp) {
 			if(vector->data[i].tcp_pbuf != NULL) {
-				pbuf_free(vector->data[i].tcp_pbuf);
+				// Don't free tcp_pbuf here. It should be freed manually outside of this code.
 				vector->data[i].tcp_pbuf = NULL;
 			}
 			vector->data[i].tcp = NULL;
@@ -54,61 +62,117 @@ int axl_free(struct tcp_pcb *tcp) {
 	return occurances;
 }
 
+
+/**
+ * Frees completely the FD mapping.
+ */
+void axl_destroy()
+{
+	if(axlFdArray.data != NULL) {
+		free(axlFdArray.data);
+	}
+	axlFdArray.size = 0;
+	axlFdArray.capacity = 0;
+}
+
 /**
  * Reads data from the SSL over TCP stream. Returns decrypted data.
  * @param SSL *sslObj
  * @param uint8_t **in_data - pointer to the decrypted incoming data, or NULL if nothing was read
  * @param void *arg - possible arguments passed to the tcp raw layer during initialization
  * @param tcp_pcb *tcp - pointer to the raw tcp object
- * @param pbuf *p - pointer to the buffer with the TCP packet data
+ * @param pbuf *pin - pointer to the buffer with the encrypted TCP packet data
+ * - the freeing of the pbuf should be done separately
+ * - the confirmation for the received bytes should be done separately
+ * @param pbuf **pout - pointer to the buffer with the decrypted TCP packet data
+ * - the freeing of the pbuf should be done separately
  *
  * @return int
  * 			0 - when everything is fine but there are no symbols to process yet
  * 			< 0 - when there is an error
  * 			> 0 - the length of the clear text characters that were read
  */
-int axl_ssl_read(SSL *ssl, uint8_t **in_data, struct tcp_pcb *tcp, struct pbuf *p) {
+int axl_ssl_read(SSL *ssl, struct tcp_pcb *tcp, struct pbuf *pin, struct pbuf **pout) {
 	int read_bytes = 0;
 	int total_bytes = 0;
 	int clientfd = -1;
-
+	uint8_t *read_buffer = NULL;
+	uint8_t *total_read_buffer = NULL;
 	AxlTcpData* data = NULL;
 
 	if (ssl == NULL) {
+		AXL_DEBUG_PRINT("axl_ssl_read: SSL is null\n");
 		return ERR_AXL_INVALID_SSL;
 	}
 
+	if(pin == NULL) {
+		AXL_DEBUG_PRINT("axl_ssl_read: PBUF is null\n");
+		return ERR_AXL_INVALID_PBUF;
+	}
+
+	if(pin->tot_len == 0) {
+		// nothing to read
+		return 0;
+	}
+
 	clientfd = ax_fd_getfd(&axlFdArray, tcp);
 	if(clientfd == -1) {
+		AXL_DEBUG_PRINT("axl_ssl_read: ClientFD not found\n");
 		return ERR_AXL_INVALID_CLIENTFD;
 	}
 
 	data = ax_fd_get(&axlFdArray, clientfd);
 	if(data == NULL) {
+		AXL_DEBUG_PRINT("axl_ssl_read: ClientFD data not found\n");
 		return ERR_AXL_INVALID_CLIENTFD_DATA;
 	}
 
-	if (p != NULL) {
-		data->tcp_pbuf = p;
-		data->pbuf_offset = 0;
-	}
-
-	AXL_DEBUG("READY TO READ SOME DATA\n");
+	data->tcp_pbuf = pin;
+	data->pbuf_offset = 0;
 
-	tcp_recved(tcp, p->tot_len);
 	do {
-		WATCHDOG_FEED();
-		read_bytes = ssl_read(ssl, in_data);
-		AXL_DEBUG("axl_ssl_read: Read bytes: %d\n", read_bytes);
+		WATCHDOG_RESET();
+		read_bytes = ssl_read(ssl, &read_buffer);
+		AXL_DEBUG_PRINT("axl_ssl_read: Read bytes: %d\n", read_bytes);
 		if(read_bytes < SSL_OK) {
 			/* An error has occurred. Give it back for further processing */
-			total_bytes = read_bytes;
+			if(total_bytes == 0) {
+				// Nothing is read so far -> give back the error
+				total_bytes = read_bytes;
+			}
+			else {
+				// We already have read some data -> deliver it back
+				// and silence the error for now..
+				AXL_DEBUG_PRINT("axl_ssl_read: Silently ignoring SSL error %d\n", read_bytes);
+			}
+
 			break;
 		}
+		else if (read_bytes > 0 ){
+			if(total_read_buffer == NULL) {
+				total_read_buffer = (uint8_t *)malloc(read_bytes);
+			}
+			else {
+				AXL_DEBUG_PRINT("axl_ssl_read: Got more than one SSL packet inside one TCP packet\n");
+				total_read_buffer = (uint8_t *)realloc(total_read_buffer, total_bytes + read_bytes);
+			}
+
+			if(total_read_buffer == NULL) {
+				AXL_DEBUG_PRINT("axl_ssl_read: Unable to allocate additional %d bytes", read_bytes);
+				while(1) {}
+			}
+
+			memcpy(total_read_buffer + total_bytes, read_buffer, read_bytes);
+		}
 		total_bytes+= read_bytes;
-	} while (p->tot_len - data->pbuf_offset > 0);
+	} while (pin->tot_len - data->pbuf_offset > 0);
 
-	pbuf_free(p);
+	if(total_bytes > 0) {
+		// put the decrypted data in a brand new pbuf
+		*pout = pbuf_alloc(PBUF_TRANSPORT, total_bytes, PBUF_RAM);
+		memcpy((*pout)->payload, total_read_buffer, total_bytes);
+		free(total_read_buffer);
+	}
 
 	return total_bytes;
 }
@@ -127,18 +191,20 @@ int ax_port_write(int clientfd, uint8_t *buf, uint16_t bytes_needed) {
 
 	data = ax_fd_get(&axlFdArray, clientfd);
 	if(data == NULL) {
+		AXL_DEBUG_PRINT("ax_port_write: Invalid ClientFD.\n");
 		return ERR_AXL_INVALID_CLIENTFD;
 	}
 
 	if (data == NULL || data->tcp == NULL || buf == NULL || bytes_needed == 0) {
-		AXL_DEBUG("Return Zero.\n");
+		AXL_DEBUG_PRINT("ax_port_write: Return Zero.\n");
 		return 0;
 	}
 
 	if (tcp_sndbuf(data->tcp) < bytes_needed) {
 		tcp_len = tcp_sndbuf(data->tcp);
 		if(tcp_len == 0) {
-			AXL_DEBUG("The send buffer is full! We have problem.\n");
+			err = tcp_output(data->tcp);
+			AXL_DEBUG_PRINT("ax_port_write: The send buffer is full! We have problem.\n");
 			return 0;
 		}
 
@@ -153,19 +219,19 @@ int ax_port_write(int clientfd, uint8_t *buf, uint16_t bytes_needed) {
 	do {
 		err = tcp_write(data->tcp, buf, tcp_len, TCP_WRITE_FLAG_COPY);
 		if(err < SSL_OK) {
-			AXL_DEBUG("Got error: %d\n", err);
+			AXL_DEBUG_PRINT("ax_port_write: Got error: %d\n", err);
 		}
 
 		if (err == ERR_MEM) {
-			AXL_DEBUG("Not enough memory to write data with length: %d (%d)\n", tcp_len, bytes_needed);
+			AXL_DEBUG_PRINT("ax_port_write: Not enough memory to write data with length: %d (%d)\n", tcp_len, bytes_needed);
 			tcp_len /= 2;
 		}
 	} while (err == ERR_MEM && tcp_len > 1);
-	AXL_DEBUG("send_raw_packet length %d(%d)\n", tcp_len, bytes_needed);
+	AXL_DEBUG_PRINT("ax_port_write: send_raw_packet length %d(%d)\n", tcp_len, bytes_needed);
 	if (err == ERR_OK) {
 		err = tcp_output(data->tcp);
 		if(err != ERR_OK) {
-			AXL_DEBUG("tcp_output got err: %d\n", err);
+			AXL_DEBUG_PRINT("ax_port_write: tcp_output got err: %d\n", err);
 		}
 	}
 
@@ -187,7 +253,7 @@ int ax_port_read(int clientfd, uint8_t *buf, int bytes_needed) {
 	}
 
 	if(data->tcp_pbuf == NULL || data->tcp_pbuf->tot_len == 0) {
-		AXL_DEBUG("Nothing to read?! May be the connection needs resetting?\n");
+		AXL_DEBUG_PRINT("ax_port_read: Nothing to read?! May be the connection needs resetting?\n");
 		return 0;
 	}
 
@@ -203,7 +269,7 @@ int ax_port_read(int clientfd, uint8_t *buf, int bytes_needed) {
 	}
 
 	if(bytes_needed < recv_len) {
-		AXL_DEBUG("Bytes needed: %d, Bytes read: %d\n", bytes_needed, recv_len);
+		AXL_DEBUG_PRINT("ax_port_read: Bytes needed: %d, Bytes read: %d\n", bytes_needed, recv_len);
 	}
 
 	free(pread_buf);
@@ -217,16 +283,22 @@ int ax_get_file(const char *filename, uint8_t **buf) {
     return 0;
 }
 
-void ax_wdt_feed() {
-}
-
 /*
  * Utility functions
+ *
+ * @param AxlTcpDataArray the tcp data vector
+ * @param int capacity - the desired capacity.
+ * @return int - the actual capacity
  */
-void ax_fd_init(AxlTcpDataArray *vector, int capacity) {
+int ax_fd_init(AxlTcpDataArray *vector, int capacity) {
 	vector->size = 0;
 	vector->capacity = capacity;
 	vector->data = (AxlTcpData*) malloc(sizeof(AxlTcpData) * vector->capacity);
+	if(vector->data == NULL) {
+		return 0;
+	}
+
+	return capacity;
 }
 
 int ax_fd_append(AxlTcpDataArray *vector, struct tcp_pcb *tcp) {
@@ -243,8 +315,7 @@ int ax_fd_append(AxlTcpDataArray *vector, struct tcp_pcb *tcp) {
 
 AxlTcpData* ax_fd_get(AxlTcpDataArray *vector, int index) {
 	if (index >= vector->size || index < 0) {
-		AXL_DEBUG("Index %d out of bounds for vector of size %d\n", index,
-				vector->size);
+		AXL_DEBUG_PRINT("ax_fd_get: Index %d out of bounds for vector of size %d\n", index, vector->size);
 		return NULL;
 	}
 	return &(vector->data[index]);
diff --git third-party/axtls-8266/compat/lwipr_compat.h third-party/axtls-8266/compat/lwipr_compat.h
index 1a8846f..0916412 100644
--- third-party/axtls-8266/compat/lwipr_compat.h
+++ third-party/axtls-8266/compat/lwipr_compat.h
@@ -25,22 +25,16 @@ extern "C" {
 #define ERR_AXL_INVALID_TCP -102
 #define ERR_AXL_INVALID_CLIENTFD -103
 #define ERR_AXL_INVALID_CLIENTFD_DATA -104
+#define ERR_AXL_INVALID_PBUF -105
 
 #define SOCKET_READ(A, B, C) 	ax_port_read(A, B, C)
 #define SOCKET_WRITE(A, B, C) 	ax_port_write(A, B, C)
 
-/*
- * Define the AXL_DEBUG function to add debug functionality
- */
-#ifndef AXL_DEBUG
-	#define AXL_DEBUG(...)
-#endif
-
 /**
  * Define watchdog function to be called during CPU intensive operations.
  */
-#ifndef WATCHDOG_FEED
-	#define WATCHDOG_FEED()
+#ifndef WATCHDOG_RESET
+	#define WATCHDOG_RESET()
 #endif
 
 typedef struct {
@@ -60,12 +54,13 @@ typedef struct {
  * High Level Functions - these are the ones that should be used directly
  */
 
-void axl_init(int capacity);
+int axl_init(int capacity);
 int axl_append(struct tcp_pcb *tcp);
 int axl_free(struct tcp_pcb *tcp);
+void axl_destroy();
 
 #define axl_ssl_write(A, B, C) ssl_write(A, B, C)
-int axl_ssl_read(SSL *sslObj, uint8_t **in_data, struct tcp_pcb *tcp, struct pbuf *p);
+int axl_ssl_read(SSL *sslObj, struct tcp_pcb *tcp, struct pbuf *pin, struct pbuf **pout);
 
 /*
  * Lower Level Socket Functions - used internally from axTLS
@@ -77,7 +72,7 @@ int ax_port_read(int clientfd, uint8_t *buf, int bytes_needed);
 /*
  * Lower Level Utility functions
  */
-void ax_fd_init(AxlTcpDataArray *vector, int capacity);
+int ax_fd_init(AxlTcpDataArray *vector, int capacity);
 int ax_fd_append(AxlTcpDataArray *vector, struct tcp_pcb *tcp);
 AxlTcpData* ax_fd_get(AxlTcpDataArray *vector, int index);
 int ax_fd_getfd(AxlTcpDataArray *vector, struct tcp_pcb *tcp);
diff --git third-party/axtls-8266/compat/lwipr_platform.h third-party/axtls-8266/compat/lwipr_platform.h
index 518e8bf..28a8c28 100644
--- third-party/axtls-8266/compat/lwipr_platform.h
+++ third-party/axtls-8266/compat/lwipr_platform.h
@@ -11,16 +11,17 @@
 
 /* Add here all platform specific things */
 
-
-// Some calls require the watchdog to be reset
-#ifndef WATCHDOG_FEED
-	#define WATCHDOG_FEED()
-#endif
+#include <user_config.h>
+//#define WATCHDOG_RESET() WDT.alive()
 
 
-/* SSL_DEBUG is for more information */
-#ifndef SSL_DEBUG
-	#define AXL_DEBUG(...)
+/*
+ * Define the AXL_DEBUG_PRINT function to add debug functionality
+ */
+#ifndef AXL_DEBUG
+	#define AXL_DEBUG_PRINT(...)
+#else
+	#define AXL_DEBUG_PRINT(...)  debugf(__VA_ARGS__)
 #endif
 
 
